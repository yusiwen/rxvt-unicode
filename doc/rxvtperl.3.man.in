.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "rxvt 3"
.TH rxvt 3 "2006-01-13" "7.0" "RXVT-UNICODE"
.SH "NAME"
@@RXVT_NAME@@perl \- rxvt\-unicode's embedded perl interpreter
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   # create a file grab_test in $HOME:
.Ve
.PP
.Vb 4
\&   sub on_sel_grab {
\&      warn "you selected ", $_[0]->selection;
\&      ()
\&   }
.Ve
.PP
.Vb 1
\&   # start a @@RXVT_NAME@@ using it:
.Ve
.PP
.Vb 1
\&   @@RXVT_NAME@@ --perl-lib $HOME -pe grab_test
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Everytime a terminal object gets created, extension scripts specified via
the \f(CW\*(C`perl\*(C'\fR resource are loaded and associated with it.
.PP
Scripts are compiled in a 'use strict' and 'use utf8' environment, and
thus must be encoded as \s-1UTF\-8\s0.
.PP
Each script will only ever be loaded once, even in @@RXVT_NAME@@d, where
scripts will be shared (but not enabled) for all terminals.
.SH "PREPACKAGED EXTENSIONS"
.IX Header "PREPACKAGED EXTENSIONS"
This section describes the extensions delivered with this release. You can
find them in \fI@@RXVT_LIBDIR@@/urxvt/perl/\fR.
.PP
You can activate them like this:
.PP
.Vb 1
\&  @@RXVT_NAME@@ -pe <extensionname>
.Ve
.IP "selection (enabled by default)" 4
.IX Item "selection (enabled by default)"
(More) intelligent selection. This extension tries to be more intelligent
when the user extends selections (double\-click and further clicks). Right
now, it tries to select words, urls and complete shell-quoted
arguments, which is very convenient, too, if your \fIls\fR supports
\&\f(CW\*(C`\-\-quoting\-style=shell\*(C'\fR.
.Sp
A double-click usually selects the word under the cursor, further clicks
will enlarge the selection.
.Sp
The selection works by trying to match a number of regexes and displaying
them in increasing order of length. You can add your own regexes by
specifying resources of the form:
.Sp
.Vb 3
\&   URxvt.selection.pattern-0: perl-regex
\&   URxvt.selection.pattern-1: perl-regex
\&   ...
.Ve
.Sp
The index number (0, 1...) must not have any holes, and each regex must
contain at least one pair of capturing parentheses, which will be used for
the match. For example, the followign adds a regex that matches everything
between two vertical bars:
.Sp
.Vb 1
\&   URxvt.selection.pattern-0: \e\e|([^|]+)\e\e|
.Ve
.Sp
You can look at the source of the selection extension to see more
interesting uses, such as parsing a line from beginning to end.
.Sp
This extension also offers the following bindable keyboard command:
.RS 4
.IP "rot13" 4
.IX Item "rot13"
Rot\-13 the selection when activated. Used via keyboard trigger:
.Sp
.Vb 1
\&   URxvt.keysym.C-M-r: perl:selection:rot13
.Ve
.RE
.RS 4
.RE
.IP "option-popup (enabled by default)" 4
.IX Item "option-popup (enabled by default)"
Binds a popup menu to Ctrl\-Button2 that lets you toggle (some) options at
runtime.
.IP "selection-popup (enabled by default)" 4
.IX Item "selection-popup (enabled by default)"
Binds a popup menu to Ctrl\-Button3 that lets you convert the selection
text into various other formats/action (such as uri unescaping, perl
evalution, web-browser starting etc.), depending on content.
.IP "searchable\-scrollback<hotkey> (enabled by default)" 4
.IX Item "searchable-scrollback<hotkey> (enabled by default)"
Adds regex search functionality to the scrollback buffer, triggered
by a hotkey (default: \f(CW\*(C`M\-s\*(C'\fR). While in search mode, normal terminal
input/output is suspended and a regex is displayed at the bottom of the
screen.
.Sp
Inputting characters appends them to the regex and continues incremental
search. \f(CW\*(C`BackSpace\*(C'\fR removes a character from the regex, \f(CW\*(C`Up\*(C'\fR and \f(CW\*(C`Down\*(C'\fR
search upwards/downwards in the scrollback buffer, \f(CW\*(C`End\*(C'\fR jumps to the
bottom. \f(CW\*(C`Escape\*(C'\fR leaves search mode and returns to the point where search
was started, while \f(CW\*(C`Enter\*(C'\fR or \f(CW\*(C`Return\*(C'\fR stay at the current position and
additionally stores the first match in the current line into the primary
selection.
.IP "selection-autotransform" 4
.IX Item "selection-autotransform"
This selection allows you to do automatic transforms on a selection
whenever a selection is made.
.Sp
It works by specifying perl snippets (most useful is a single \f(CW\*(C`s///\*(C'\fR
operator) that modify \f(CW$_\fR as resources:
.Sp
.Vb 3
\&   URxvt.selection-autotransform.0: transform
\&   URxvt.selection-autotransform.1: transform
\&   ...
.Ve
.Sp
For example, the following will transform selections of the form
\&\f(CW\*(C`filename:number\*(C'\fR, often seen in compiler messages, into \f(CW\*(C`vi +$filename
$word\*(C'\fR:
.Sp
.Vb 1
\&   URxvt.selection-autotransform.0: s/^([^:[:space:]]+):(\e\ed+):?$/vi +$2 \e\eQ$1\e\eE\e\ex0d/
.Ve
.Sp
And this example matches the same,but replaces it with vi-commands you can
paste directly into your (vi :) editor:
.Sp
.Vb 1
\&   URxvt.selection-autotransform.0: s/^([^:[:space:]]+(\e\ed+):?$/\e\ex1b:e \e\eQ$1\e\eE\e\ex0d:$2\e\ex0d/
.Ve
.Sp
Of course, this can be modified to suit your needs and your editor :)
.Sp
To expand the example above to typical perl error messages (\*(L"\s-1XXX\s0 at
\&\s-1FILENAME\s0 line \s-1YYY\s0.\*(R"), you need a slightly more elaborate solution:
.Sp
.Vb 2
\&   URxvt.selection.pattern-0: ( at .*? line \e\ed+\e\e.)
\&   URxvt.selection-autotransform.0: s/^ at (.*?) line (\e\ed+)\e\e.$/\ex1b:e \e\eQ$1\eE\e\ex0d:$2\e\ex0d/
.Ve
.Sp
The first line tells the selection code to treat the unchanging part of
every error message as a selection pattern, and the second line transforms
the message into vi commands to load the file.
.IP "mark-urls" 4
.IX Item "mark-urls"
Uses per-line display filtering (\f(CW\*(C`on_line_update\*(C'\fR) to underline urls and
make them clickable. When middle\-clicked, the program specified in the
resource \f(CW\*(C`urlLauncher\*(C'\fR (default \f(CW\*(C`x\-www\-browser\*(C'\fR) will be started with
the \s-1URL\s0 as first argument.
.IP "block-graphics-to-ascii" 4
.IX Item "block-graphics-to-ascii"
A not very useful example of filtering all text output to the terminal,
by replacing all line-drawing characters (U+2500 .. U+259F) by a
similar-looking ascii character.
.IP "digital-clock" 4
.IX Item "digital-clock"
Displays a digital clock using the built-in overlay.
.IP "example-refresh-hooks" 4
.IX Item "example-refresh-hooks"
Displays a very simple digital clock in the upper right corner of the
window. Illustrates overwriting the refresh callbacks to create your own
overlays or changes.
.SH "API DOCUMENTATION"
.IX Header "API DOCUMENTATION"
.Sh "General \s-1API\s0 Considerations"
.IX Subsection "General API Considerations"
All objects (such as terminals, time watchers etc.) are typical
reference-to-hash objects. The hash can be used to store anything you
like. All members starting with an underscore (such as \f(CW\*(C`_ptr\*(C'\fR or
\&\f(CW\*(C`_hook\*(C'\fR) are reserved for internal uses and \fB\s-1MUST\s0 \s-1NOT\s0\fR be accessed or
modified).
.PP
When objects are destroyed on the \*(C+ side, the perl object hashes are
emptied, so its best to store related objects such as time watchers and
the like inside the terminal object so they get destroyed as soon as the
terminal is destroyed.
.PP
Argument names also often indicate the type of a parameter. Here are some
hints on what they mean:
.IP "$text" 4
.IX Item "$text"
Rxvt-unicodes special way of encoding text, where one \*(L"unicode\*(R" character
always represents one screen cell. See ROW_t for a discussion of this format.
.IP "$string" 4
.IX Item "$string"
A perl text string, with an emphasis on \fItext\fR. It can store all unicode
characters and is to be distinguished with text encoded in a specific
encoding (often locale\-specific) and binary data.
.IP "$octets" 4
.IX Item "$octets"
Either binary data or \- more common \- a text string encoded in a
locale-specific way.
.Sh "Extension Objects"
.IX Subsection "Extension Objects"
Very perl extension is a perl class. A separate perl object is created
for each terminal and each extension and passed as the first parameter to
hooks. So extensions can use their \f(CW$self\fR object without having to think
about other extensions, with the exception of methods and members that
begin with an underscore character \f(CW\*(C`_\*(C'\fR: these are reserved for internal
use.
.PP
Although it isn't a \f(CW\*(C`urxvt::term\*(C'\fR object, you can call all methods of the
\&\f(CW\*(C`urxvt::term\*(C'\fR class on this object.
.PP
It has the following methods and data members:
.ie n .IP "$urxvt_term = $self\->{term}" 4
.el .IP "$urxvt_term = \f(CW$self\fR\->{term}" 4
.IX Item "$urxvt_term = $self->{term}"
Returns the \f(CW\*(C`urxvt::term\*(C'\fR object associated with this instance of the
extension. This member \fImust not\fR be changed in any way.
.ie n .IP "$self\->enable ($hook_name => $cb\fR, [$hook_name => \f(CW$cb..])" 4
.el .IP "$self\->enable ($hook_name => \f(CW$cb\fR, [$hook_name => \f(CW$cb\fR..])" 4
.IX Item "$self->enable ($hook_name => $cb, [$hook_name => $cb..])"
Dynamically enable the given hooks (named without the \f(CW\*(C`on_\*(C'\fR prefix) for
this extension, replacing any previous hook. This is useful when you want
to overwrite time-critical hooks only temporarily.
.ie n .IP "$self\->disable ($hook_name[, $hook_name..])" 4
.el .IP "$self\->disable ($hook_name[, \f(CW$hook_name\fR..])" 4
.IX Item "$self->disable ($hook_name[, $hook_name..])"
Dynamically disable the given hooks.
.Sh "Hooks"
.IX Subsection "Hooks"
The following subroutines can be declared in extension files, and will be
called whenever the relevant event happens.
.PP
The first argument passed to them is an extension oject as described in
the in the \f(CW\*(C`Extension Objects\*(C'\fR section.
.PP
\&\fBAll\fR of these hooks must return a boolean value. If it is true, then the
event counts as being \fIconsumed\fR, and the invocation of other hooks is
skipped, and the relevant action might not be carried out by the \*(C+ code.
.PP
\&\fIWhen in doubt, return a false value (preferably \f(CI\*(C`()\*(C'\fI).\fR
.ie n .IP "on_init $term" 4
.el .IP "on_init \f(CW$term\fR" 4
.IX Item "on_init $term"
Called after a new terminal object has been initialized, but before
windows are created or the command gets run. Most methods are unsafe to
call or deliver senseless data, as terminal size and other characteristics
have not yet been determined. You can safely query and change resources,
though.
.ie n .IP "on_reset $term" 4
.el .IP "on_reset \f(CW$term\fR" 4
.IX Item "on_reset $term"
Called after the screen is \*(L"reset\*(R" for any reason, such as resizing or
control sequences. Here is where you can react on changes to size-related
variables.
.ie n .IP "on_start $term" 4
.el .IP "on_start \f(CW$term\fR" 4
.IX Item "on_start $term"
Called at the very end of initialisation of a new terminal, just before
returning to the mainloop.
.ie n .IP "on_sel_make $term\fR, \f(CW$eventtime" 4
.el .IP "on_sel_make \f(CW$term\fR, \f(CW$eventtime\fR" 4
.IX Item "on_sel_make $term, $eventtime"
Called whenever a selection has been made by the user, but before the
selection text is copied, so changes to the beginning, end or type of the
selection will be honored.
.Sp
Returning a true value aborts selection making by urxvt, in which case you
have to make a selection yourself by calling \f(CW\*(C`$term\->selection_grab\*(C'\fR.
.ie n .IP "on_sel_grab $term\fR, \f(CW$eventtime" 4
.el .IP "on_sel_grab \f(CW$term\fR, \f(CW$eventtime\fR" 4
.IX Item "on_sel_grab $term, $eventtime"
Called whenever a selection has been copied, but before the selection is
requested from the server.  The selection text can be queried and changed
by calling \f(CW\*(C`$term\->selection\*(C'\fR.
.Sp
Returning a true value aborts selection grabbing. It will still be hilighted.
.ie n .IP "on_sel_extend $term" 4
.el .IP "on_sel_extend \f(CW$term\fR" 4
.IX Item "on_sel_extend $term"
Called whenever the user tries to extend the selection (e.g. with a double
click) and is either supposed to return false (normal operation), or
should extend the selection itelf and return true to suppress the built-in
processing. This can happen multiple times, as long as the callback
returns true, it will be called on every further click by the user and is
supposed to enlarge the selection more and more, if possible.
.Sp
See the \fIselection\fR example extension.
.ie n .IP "on_view_change $term\fR, \f(CW$offset" 4
.el .IP "on_view_change \f(CW$term\fR, \f(CW$offset\fR" 4
.IX Item "on_view_change $term, $offset"
Called whenever the view offset changes, i..e the user or program
scrolls. Offset \f(CW0\fR means display the normal terminal, positive values
show this many lines of scrollback.
.ie n .IP "on_scroll_back $term\fR, \f(CW$lines\fR, \f(CW$saved" 4
.el .IP "on_scroll_back \f(CW$term\fR, \f(CW$lines\fR, \f(CW$saved\fR" 4
.IX Item "on_scroll_back $term, $lines, $saved"
Called whenever lines scroll out of the terminal area into the scrollback
buffer. \f(CW$lines\fR is the number of lines scrolled out and may be larger
than the scroll back buffer or the terminal.
.Sp
It is called before lines are scrolled out (so rows 0 .. min ($lines \- 1,
\&\f(CW$nrow\fR \- 1) represent the lines to be scrolled out). \f(CW$saved\fR is the total
number of lines that will be in the scrollback buffer.
.ie n .IP "on_osc_seq $term\fR, \f(CW$string" 4
.el .IP "on_osc_seq \f(CW$term\fR, \f(CW$string\fR" 4
.IX Item "on_osc_seq $term, $string"
Called whenever the \fB\s-1ESC\s0 ] 777 ; string \s-1ST\s0\fR command sequence (\s-1OSC\s0 =
operating system command) is processed. Cursor position and other state
information is up-to-date when this happens. For interoperability, the
string should start with the extension name and a colon, to distinguish
it from commands for other extensions, and this might be enforced in the
future.
.Sp
Be careful not ever to trust (in a security sense) the data you receive,
as its source can not easily be controleld (e\-mail content, messages from
other users on the same system etc.).
.ie n .IP "on_add_lines $term\fR, \f(CW$string" 4
.el .IP "on_add_lines \f(CW$term\fR, \f(CW$string\fR" 4
.IX Item "on_add_lines $term, $string"
Called whenever text is about to be output, with the text as argument. You
can filter/change and output the text yourself by returning a true value
and calling \f(CW\*(C`$term\->scr_add_lines\*(C'\fR yourself. Please note that this
might be very slow, however, as your hook is called for \fBall\fR text being
output.
.ie n .IP "on_tt_write $term\fR, \f(CW$octets" 4
.el .IP "on_tt_write \f(CW$term\fR, \f(CW$octets\fR" 4
.IX Item "on_tt_write $term, $octets"
Called whenever some data is written to the tty/pty and can be used to
suppress or filter tty input.
.ie n .IP "on_line_update $term\fR, \f(CW$row" 4
.el .IP "on_line_update \f(CW$term\fR, \f(CW$row\fR" 4
.IX Item "on_line_update $term, $row"
Called whenever a line was updated or changed. Can be used to filter
screen output (e.g. underline urls or other useless stuff). Only lines
that are being shown will be filtered, and, due to performance reasons,
not always immediately.
.Sp
The row number is always the topmost row of the line if the line spans
multiple rows.
.Sp
Please note that, if you change the line, then the hook might get called
later with the already-modified line (e.g. if unrelated parts change), so
you cannot just toggle rendition bits, but only set them.
.ie n .IP "on_refresh_begin $term" 4
.el .IP "on_refresh_begin \f(CW$term\fR" 4
.IX Item "on_refresh_begin $term"
Called just before the screen gets redrawn. Can be used for overlay
or similar effects by modify terminal contents in refresh_begin, and
restoring them in refresh_end. The built-in overlay and selection display
code is run after this hook, and takes precedence.
.ie n .IP "on_refresh_end $term" 4
.el .IP "on_refresh_end \f(CW$term\fR" 4
.IX Item "on_refresh_end $term"
Called just after the screen gets redrawn. See \f(CW\*(C`on_refresh_begin\*(C'\fR.
.ie n .IP "on_keyboard_command $term\fR, \f(CW$string" 4
.el .IP "on_keyboard_command \f(CW$term\fR, \f(CW$string\fR" 4
.IX Item "on_keyboard_command $term, $string"
Called whenever the user presses a key combination that has a
\&\f(CW\*(C`perl:string\*(C'\fR action bound to it (see description of the \fBkeysym\fR
resource in the @@RXVT_NAME@@(1) manpage).
.ie n .IP "on_x_event $term\fR, \f(CW$event" 4
.el .IP "on_x_event \f(CW$term\fR, \f(CW$event\fR" 4
.IX Item "on_x_event $term, $event"
Called on every X event received on the vt window (and possibly other
windows). Should only be used as a last resort. Most event structure
members are not passed.
.ie n .IP "on_focus_in $term" 4
.el .IP "on_focus_in \f(CW$term\fR" 4
.IX Item "on_focus_in $term"
Called whenever the window gets the keyboard focus, before rxvt-unicode
does focus in processing.
.ie n .IP "on_focus_out $term" 4
.el .IP "on_focus_out \f(CW$term\fR" 4
.IX Item "on_focus_out $term"
Called wheneever the window loses keyboard focus, before rxvt-unicode does
focus out processing.
.ie n .IP "on_key_press $term\fR, \f(CW$event\fR, \f(CW$keysym\fR, \f(CW$octets" 4
.el .IP "on_key_press \f(CW$term\fR, \f(CW$event\fR, \f(CW$keysym\fR, \f(CW$octets\fR" 4
.IX Item "on_key_press $term, $event, $keysym, $octets"
.PD 0
.ie n .IP "on_key_release $term\fR, \f(CW$event\fR, \f(CW$keysym" 4
.el .IP "on_key_release \f(CW$term\fR, \f(CW$event\fR, \f(CW$keysym\fR" 4
.IX Item "on_key_release $term, $event, $keysym"
.ie n .IP "on_button_press $term\fR, \f(CW$event" 4
.el .IP "on_button_press \f(CW$term\fR, \f(CW$event\fR" 4
.IX Item "on_button_press $term, $event"
.ie n .IP "on_button_release $term\fR, \f(CW$event" 4
.el .IP "on_button_release \f(CW$term\fR, \f(CW$event\fR" 4
.IX Item "on_button_release $term, $event"
.ie n .IP "on_motion_notify $term\fR, \f(CW$event" 4
.el .IP "on_motion_notify \f(CW$term\fR, \f(CW$event\fR" 4
.IX Item "on_motion_notify $term, $event"
.ie n .IP "on_map_notify $term\fR, \f(CW$event" 4
.el .IP "on_map_notify \f(CW$term\fR, \f(CW$event\fR" 4
.IX Item "on_map_notify $term, $event"
.ie n .IP "on_unmap_notify $term\fR, \f(CW$event" 4
.el .IP "on_unmap_notify \f(CW$term\fR, \f(CW$event\fR" 4
.IX Item "on_unmap_notify $term, $event"
.PD
Called whenever the corresponding X event is received for the terminal If
the hook returns true, then the even will be ignored by rxvt\-unicode.
.Sp
The event is a hash with most values as named by Xlib (see the XEvent
manpage), with the additional members \f(CW\*(C`row\*(C'\fR and \f(CW\*(C`col\*(C'\fR, which are the row
and column under the mouse cursor.
.Sp
\&\f(CW\*(C`on_key_press\*(C'\fR additionally receives the string rxvt-unicode would
output, if any, in locale-specific encoding.
.Sp
subwindow.
.ie n .Sh "Variables in the ""urxvt"" Package"
.el .Sh "Variables in the \f(CWurxvt\fP Package"
.IX Subsection "Variables in the urxvt Package"
.IP "$urxvt::LIBDIR" 4
.IX Item "$urxvt::LIBDIR"
The rxvt-unicode library directory, where, among other things, the perl
modules and scripts are stored.
.ie n .IP "$urxvt::RESCLASS, $urxvt::RESCLASS" 4
.el .IP "$urxvt::RESCLASS, \f(CW$urxvt::RESCLASS\fR" 4
.IX Item "$urxvt::RESCLASS, $urxvt::RESCLASS"
The resource class and name rxvt-unicode uses to look up X resources.
.IP "$urxvt::RXVTNAME" 4
.IX Item "$urxvt::RXVTNAME"
The basename of the installed binaries, usually \f(CW\*(C`urxvt\*(C'\fR.
.IP "$urxvt::TERM" 4
.IX Item "$urxvt::TERM"
The current terminal. This variable stores the current \f(CW\*(C`urxvt::term\*(C'\fR
object, whenever a callback/hook is executing.
.ie n .Sh "Functions in the ""urxvt"" Package"
.el .Sh "Functions in the \f(CWurxvt\fP Package"
.IX Subsection "Functions in the urxvt Package"
.ie n .IP "urxvt::fatal $errormessage" 4
.el .IP "urxvt::fatal \f(CW$errormessage\fR" 4
.IX Item "urxvt::fatal $errormessage"
Fatally aborts execution with the given error message. Avoid at all
costs! The only time this is acceptable is when the terminal process
starts up.
.ie n .IP "urxvt::warn $string" 4
.el .IP "urxvt::warn \f(CW$string\fR" 4
.IX Item "urxvt::warn $string"
Calls \f(CW\*(C`rxvt_warn\*(C'\fR with the given string which should not include a
newline. The module also overwrites the \f(CW\*(C`warn\*(C'\fR builtin with a function
that calls this function.
.Sp
Using this function has the advantage that its output ends up in the
correct place, e.g. on stderr of the connecting urxvtc client.
.Sp
Messages have a size limit of 1023 bytes currently.
.IP "$is_safe = urxvt::safe" 4
.IX Item "$is_safe = urxvt::safe"
Returns true when it is safe to do potentially unsafe things, such as
evaluating perl code specified by the user. This is true when urxvt was
started setuid or setgid.
.IP "$time = urxvt::NOW" 4
.IX Item "$time = urxvt::NOW"
Returns the \*(L"current time\*(R" (as per the event loop).
.IP "urxvt::CurrentTime" 4
.IX Item "urxvt::CurrentTime"
.PD 0
.IP "urxvt::ShiftMask, LockMask, ControlMask, Mod1Mask, Mod2Mask, Mod3Mask, Mod4Mask, Mod5Mask, Button1Mask, Button2Mask, Button3Mask, Button4Mask, Button5Mask, AnyModifier" 4
.IX Item "urxvt::ShiftMask, LockMask, ControlMask, Mod1Mask, Mod2Mask, Mod3Mask, Mod4Mask, Mod5Mask, Button1Mask, Button2Mask, Button3Mask, Button4Mask, Button5Mask, AnyModifier"
.IP "urxvt::NoEventMask, KeyPressMask, KeyReleaseMask, ButtonPressMask, ButtonReleaseMask, EnterWindowMask, LeaveWindowMask, PointerMotionMask, PointerMotionHintMask, Button1MotionMask, Button2MotionMask, Button3MotionMask, Button4MotionMask, Button5MotionMask, ButtonMotionMask, KeymapStateMask, ExposureMask, VisibilityChangeMask, StructureNotifyMask, ResizeRedirectMask, SubstructureNotifyMask, SubstructureRedirectMask, FocusChangeMask, PropertyChangeMask, ColormapChangeMask, OwnerGrabButtonMask" 4
.IX Item "urxvt::NoEventMask, KeyPressMask, KeyReleaseMask, ButtonPressMask, ButtonReleaseMask, EnterWindowMask, LeaveWindowMask, PointerMotionMask, PointerMotionHintMask, Button1MotionMask, Button2MotionMask, Button3MotionMask, Button4MotionMask, Button5MotionMask, ButtonMotionMask, KeymapStateMask, ExposureMask, VisibilityChangeMask, StructureNotifyMask, ResizeRedirectMask, SubstructureNotifyMask, SubstructureRedirectMask, FocusChangeMask, PropertyChangeMask, ColormapChangeMask, OwnerGrabButtonMask"
.IP "urxvt::KeyPress, KeyRelease, ButtonPress, ButtonRelease, MotionNotify, EnterNotify, LeaveNotify, FocusIn, FocusOut, KeymapNotify, Expose, GraphicsExpose, NoExpose, VisibilityNotify, CreateNotify, DestroyNotify, UnmapNotify, MapNotify, MapRequest, ReparentNotify, ConfigureNotify, ConfigureRequest, GravityNotify, ResizeRequest, CirculateNotify, CirculateRequest, PropertyNotify, SelectionClear, SelectionRequest, SelectionNotify, ColormapNotify, ClientMessage, MappingNotify" 4
.IX Item "urxvt::KeyPress, KeyRelease, ButtonPress, ButtonRelease, MotionNotify, EnterNotify, LeaveNotify, FocusIn, FocusOut, KeymapNotify, Expose, GraphicsExpose, NoExpose, VisibilityNotify, CreateNotify, DestroyNotify, UnmapNotify, MapNotify, MapRequest, ReparentNotify, ConfigureNotify, ConfigureRequest, GravityNotify, ResizeRequest, CirculateNotify, CirculateRequest, PropertyNotify, SelectionClear, SelectionRequest, SelectionNotify, ColormapNotify, ClientMessage, MappingNotify"
.PD
Various constants for use in X calls and event processing.
.Sh "\s-1RENDITION\s0"
.IX Subsection "RENDITION"
Rendition bitsets contain information about colour, font, font styles and
similar information for each screen cell.
.PP
The following \*(L"macros\*(R" deal with changes in rendition sets. You should
never just create a bitset, you should always modify an existing one,
as they contain important information required for correct operation of
rxvt\-unicode.
.IP "$rend = urxvt::DEFAULT_RSTYLE" 4
.IX Item "$rend = urxvt::DEFAULT_RSTYLE"
Returns the default rendition, as used when the terminal is starting up or
being reset. Useful as a base to start when creating renditions.
.IP "$rend = urxvt::OVERLAY_RSTYLE" 4
.IX Item "$rend = urxvt::OVERLAY_RSTYLE"
Return the rendition mask used for overlays by default.
.IP "$rendbit = urxvt::RS_Bold, RS_Italic, RS_Blink, RS_RVid, RS_Uline" 4
.IX Item "$rendbit = urxvt::RS_Bold, RS_Italic, RS_Blink, RS_RVid, RS_Uline"
Return the bit that enabled bold, italic, blink, reverse-video and
underline, respectively. To enable such a style, just logically \s-1OR\s0 it into
the bitset.
.ie n .IP "$foreground = urxvt::GET_BASEFG $rend" 4
.el .IP "$foreground = urxvt::GET_BASEFG \f(CW$rend\fR" 4
.IX Item "$foreground = urxvt::GET_BASEFG $rend"
.PD 0
.ie n .IP "$background = urxvt::GET_BASEBG $rend" 4
.el .IP "$background = urxvt::GET_BASEBG \f(CW$rend\fR" 4
.IX Item "$background = urxvt::GET_BASEBG $rend"
.PD
Return the foreground/background colour index, respectively.
.ie n .IP "$rend = urxvt::SET_FGCOLOR $rend\fR, \f(CW$new_colour" 4
.el .IP "$rend = urxvt::SET_FGCOLOR \f(CW$rend\fR, \f(CW$new_colour\fR" 4
.IX Item "$rend = urxvt::SET_FGCOLOR $rend, $new_colour"
.PD 0
.ie n .IP "$rend = urxvt::SET_BGCOLOR $rend\fR, \f(CW$new_colour" 4
.el .IP "$rend = urxvt::SET_BGCOLOR \f(CW$rend\fR, \f(CW$new_colour\fR" 4
.IX Item "$rend = urxvt::SET_BGCOLOR $rend, $new_colour"
.PD
Replace the foreground/background colour in the rendition mask with the
specified one.
.ie n .IP "$value = urxvt::GET_CUSTOM $rend" 4
.el .IP "$value = urxvt::GET_CUSTOM \f(CW$rend\fR" 4
.IX Item "$value = urxvt::GET_CUSTOM $rend"
Return the \*(L"custom\*(R" value: Every rendition has 5 bits for use by
extensions. They can be set and changed as you like and are initially
zero.
.ie n .IP "$rend = urxvt::SET_CUSTOM $rend\fR, \f(CW$new_value" 4
.el .IP "$rend = urxvt::SET_CUSTOM \f(CW$rend\fR, \f(CW$new_value\fR" 4
.IX Item "$rend = urxvt::SET_CUSTOM $rend, $new_value"
Change the custom value.
.ie n .Sh "The ""urxvt::anyevent"" Class"
.el .Sh "The \f(CWurxvt::anyevent\fP Class"
.IX Subsection "The urxvt::anyevent Class"
The sole purpose of this class is to deliver an interface to the
\&\f(CW\*(C`AnyEvent\*(C'\fR module \- any module using it will work inside urxvt without
further programming. The only exception is that you cannot wait on
condition variables, but non-blocking condvar use is ok. What this means
is that you cannot use blocking APIs, but the non-blocking variant should
work.
.ie n .Sh "The ""urxvt::term"" Class"
.el .Sh "The \f(CWurxvt::term\fP Class"
.IX Subsection "The urxvt::term Class"
.ie n .IP "$term = new urxvt::term $envhashref\fR, \f(CW$rxvtname, [arg...]" 4
.el .IP "$term = new urxvt::term \f(CW$envhashref\fR, \f(CW$rxvtname\fR, [arg...]" 4
.IX Item "$term = new urxvt::term $envhashref, $rxvtname, [arg...]"
Creates a new terminal, very similar as if you had started it with system
\&\f(CW\*(C`$rxvtname, arg...\*(C'\fR. \f(CW$envhashref\fR must be a reference to a \f(CW%ENV\fR\-like
hash which defines the environment of the new terminal.
.Sp
Croaks (and probably outputs an error message) if the new instance
couldn't be created.  Returns \f(CW\*(C`undef\*(C'\fR if the new instance didn't
initialise perl, and the terminal object otherwise. The \f(CW\*(C`init\*(C'\fR and
\&\f(CW\*(C`start\*(C'\fR hooks will be called during this call.
.IP "$term\->destroy" 4
.IX Item "$term->destroy"
Destroy the terminal object (close the window, free resources
etc.). Please note that @@RXVT_NAME@@ will not exit as long as any event
watchers (timers, io watchers) are still active.
.ie n .IP "$isset = $term\fR\->option ($optval[, \f(CW$set])" 4
.el .IP "$isset = \f(CW$term\fR\->option ($optval[, \f(CW$set\fR])" 4
.IX Item "$isset = $term->option ($optval[, $set])"
Returns true if the option specified by \f(CW$optval\fR is enabled, and
optionally change it. All option values are stored by name in the hash
\&\f(CW%urxvt::OPTION\fR. Options not enabled in this binary are not in the hash.
.Sp
Here is a a likely non-exhaustive list of option names, please see the
source file \fI/src/optinc.h\fR to see the actual list:
.Sp
.Vb 6
\& borderLess console cursorBlink cursorUnderline hold iconic insecure
\& intensityStyles jumpScroll loginShell mapAlert meta8 mouseWheelScrollPage
\& pastableTabs pointerBlank reverseVideo scrollBar scrollBar_floating
\& scrollBar_right scrollTtyKeypress scrollTtyOutput scrollWithBuffer
\& secondaryScreen secondaryScroll skipBuiltinGlyphs transparent
\& tripleclickwords utmpInhibit visualBell
.Ve
.ie n .IP "$value = $term\fR\->resource ($name[, \f(CW$newval])" 4
.el .IP "$value = \f(CW$term\fR\->resource ($name[, \f(CW$newval\fR])" 4
.IX Item "$value = $term->resource ($name[, $newval])"
Returns the current resource value associated with a given name and
optionally sets a new value. Setting values is most useful in the \f(CW\*(C`init\*(C'\fR
hook. Unset resources are returned and accepted as \f(CW\*(C`undef\*(C'\fR.
.Sp
The new value must be properly encoded to a suitable character encoding
before passing it to this method. Similarly, the returned value may need
to be converted from the used encoding to text.
.Sp
Resource names are as defined in \fIsrc/rsinc.h\fR. Colours can be specified
as resource names of the form \f(CW\*(C`color+<index>\*(C'\fR, e.g. \f(CW\*(C`color+5\*(C'\fR. (will
likely change).
.Sp
Please note that resource strings will currently only be freed when the
terminal is destroyed, so changing options frequently will eat memory.
.Sp
Here is a a likely non-exhaustive list of resource names, not all of which
are supported in every build, please see the source file \fI/src/rsinc.h\fR
to see the actual list:
.Sp
.Vb 12
\&  answerbackstring backgroundPixmap backspace_key boldFont boldItalicFont
\&  borderLess color cursorBlink cursorUnderline cutchars delete_key
\&  display_name embed ext_bwidth fade font geometry hold iconName
\&  imFont imLocale inputMethod insecure int_bwidth intensityStyles
\&  italicFont jumpScroll lineSpace loginShell mapAlert menu meta8 modifier
\&  mouseWheelScrollPage name pastableTabs path perl_eval perl_ext_1 perl_ext_2
\&  perl_lib pointerBlank pointerBlankDelay preeditType print_pipe pty_fd
\&  reverseVideo saveLines scrollBar scrollBar_align scrollBar_floating
\&  scrollBar_right scrollBar_thickness scrollTtyKeypress scrollTtyOutput
\&  scrollWithBuffer scrollstyle secondaryScreen secondaryScroll selectstyle
\&  shade term_name title transparent transparent_all tripleclickwords
\&  utmpInhibit visualBell
.Ve
.ie n .IP "$value = $term\->x_resource ($pattern)" 4
.el .IP "$value = \f(CW$term\fR\->x_resource ($pattern)" 4
.IX Item "$value = $term->x_resource ($pattern)"
Returns the X\-Resource for the given pattern, excluding the program or
class name, i.e.  \f(CW\*(C`$term\->x_resource ("boldFont")\*(C'\fR should return the
same value as used by this instance of rxvt\-unicode. Returns \f(CW\*(C`undef\*(C'\fR if no
resource with that pattern exists.
.Sp
This method should only be called during the \f(CW\*(C`on_start\*(C'\fR hook, as there is
only one resource database per display, and later invocations might return
the wrong resources.
.ie n .IP "$success = $term\fR\->parse_keysym ($keysym_spec, \f(CW$command_string)" 4
.el .IP "$success = \f(CW$term\fR\->parse_keysym ($keysym_spec, \f(CW$command_string\fR)" 4
.IX Item "$success = $term->parse_keysym ($keysym_spec, $command_string)"
Adds a keymap translation exactly as specified via a resource. See the
\&\f(CW\*(C`keysym\*(C'\fR resource in the @@RXVT_NAME@@(1) manpage.
.ie n .IP "$rend = $term\->rstyle ([$new_rstyle])" 4
.el .IP "$rend = \f(CW$term\fR\->rstyle ([$new_rstyle])" 4
.IX Item "$rend = $term->rstyle ([$new_rstyle])"
Return and optionally change the current rendition. Text that is output by
the terminal application will use this style.
.ie n .IP "($row, $col\fR) = \f(CW$term\fR\->screen_cur ([$row, \f(CW$col])" 4
.el .IP "($row, \f(CW$col\fR) = \f(CW$term\fR\->screen_cur ([$row, \f(CW$col\fR])" 4
.IX Item "($row, $col) = $term->screen_cur ([$row, $col])"
Return the current coordinates of the text cursor position and optionally
set it (which is usually bad as applications don't expect that).
.ie n .IP "($row, $col\fR) = \f(CW$term\fR\->selection_mark ([$row, \f(CW$col])" 4
.el .IP "($row, \f(CW$col\fR) = \f(CW$term\fR\->selection_mark ([$row, \f(CW$col\fR])" 4
.IX Item "($row, $col) = $term->selection_mark ([$row, $col])"
.PD 0
.ie n .IP "($row, $col\fR) = \f(CW$term\fR\->selection_beg ([$row, \f(CW$col])" 4
.el .IP "($row, \f(CW$col\fR) = \f(CW$term\fR\->selection_beg ([$row, \f(CW$col\fR])" 4
.IX Item "($row, $col) = $term->selection_beg ([$row, $col])"
.ie n .IP "($row, $col\fR) = \f(CW$term\fR\->selection_end ([$row, \f(CW$col])" 4
.el .IP "($row, \f(CW$col\fR) = \f(CW$term\fR\->selection_end ([$row, \f(CW$col\fR])" 4
.IX Item "($row, $col) = $term->selection_end ([$row, $col])"
.PD
Return the current values of the selection mark, begin or end positions,
and optionally set them to new values.
.ie n .IP "$term\->selection_make ($eventtime[, $rectangular])" 4
.el .IP "$term\->selection_make ($eventtime[, \f(CW$rectangular\fR])" 4
.IX Item "$term->selection_make ($eventtime[, $rectangular])"
Tries to make a selection as set by \f(CW\*(C`selection_beg\*(C'\fR and
\&\f(CW\*(C`selection_end\*(C'\fR. If \f(CW$rectangular\fR is true (default: false), a
rectangular selection will be made. This is the prefered function to make
a selection.
.ie n .IP "$success = $term\->selection_grab ($eventtime)" 4
.el .IP "$success = \f(CW$term\fR\->selection_grab ($eventtime)" 4
.IX Item "$success = $term->selection_grab ($eventtime)"
Try to request the primary selection text from the server (for example, as
set by the next method). No visual feedback will be given. This function
is mostly useful from within \f(CW\*(C`on_sel_grab\*(C'\fR hooks.
.ie n .IP "$oldtext = $term\->selection ([$newtext])" 4
.el .IP "$oldtext = \f(CW$term\fR\->selection ([$newtext])" 4
.IX Item "$oldtext = $term->selection ([$newtext])"
Return the current selection text and optionally replace it by \f(CW$newtext\fR.
.ie n .IP "$term\->overlay_simple ($x, $y\fR, \f(CW$text)" 4
.el .IP "$term\->overlay_simple ($x, \f(CW$y\fR, \f(CW$text\fR)" 4
.IX Item "$term->overlay_simple ($x, $y, $text)"
Create a simple multi-line overlay box. See the next method for details.
.ie n .IP "$term\->overlay ($x, $y\fR, \f(CW$width\fR, \f(CW$height\fR[, \f(CW$rstyle\fR[, \f(CW$border]])" 4
.el .IP "$term\->overlay ($x, \f(CW$y\fR, \f(CW$width\fR, \f(CW$height\fR[, \f(CW$rstyle\fR[, \f(CW$border\fR]])" 4
.IX Item "$term->overlay ($x, $y, $width, $height[, $rstyle[, $border]])"
Create a new (empty) overlay at the given position with the given
width/height. \f(CW$rstyle\fR defines the initial rendition style
(default: \f(CW\*(C`OVERLAY_RSTYLE\*(C'\fR).
.Sp
If \f(CW$border\fR is \f(CW2\fR (default), then a decorative border will be put
around the box.
.Sp
If either \f(CW$x\fR or \f(CW$y\fR is negative, then this is counted from the
right/bottom side, respectively.
.Sp
This method returns an urxvt::overlay object. The overlay will be visible
as long as the perl object is referenced.
.Sp
The methods currently supported on \f(CW\*(C`urxvt::overlay\*(C'\fR objects are:
.RS 4
.ie n .IP "$overlay\->set ($x, $y\fR, \f(CW$text\fR, \f(CW$rend)" 4
.el .IP "$overlay\->set ($x, \f(CW$y\fR, \f(CW$text\fR, \f(CW$rend\fR)" 4
.IX Item "$overlay->set ($x, $y, $text, $rend)"
Similar to \f(CW\*(C`$term\->ROW_t\*(C'\fR and \f(CW\*(C`$term\->ROW_r\*(C'\fR in that it puts
text in rxvt\-unicode's special encoding and an array of rendition values
at a specific position inside the overlay.
.IP "$overlay\->hide" 4
.IX Item "$overlay->hide"
If visible, hide the overlay, but do not destroy it.
.IP "$overlay\->show" 4
.IX Item "$overlay->show"
If hidden, display the overlay again.
.RE
.RS 4
.RE
.ie n .IP "$popup = $term\->popup ($event)" 4
.el .IP "$popup = \f(CW$term\fR\->popup ($event)" 4
.IX Item "$popup = $term->popup ($event)"
Creates a new \f(CW\*(C`urxvt::popup\*(C'\fR object that implements a popup menu. The
\&\f(CW$event\fR \fImust\fR be the event causing the menu to pop up (a button event,
currently).
.ie n .IP "$cellwidth = $term\->strwidth ($string)" 4
.el .IP "$cellwidth = \f(CW$term\fR\->strwidth ($string)" 4
.IX Item "$cellwidth = $term->strwidth ($string)"
Returns the number of screen-cells this string would need. Correctly
accounts for wide and combining characters.
.ie n .IP "$octets = $term\->locale_encode ($string)" 4
.el .IP "$octets = \f(CW$term\fR\->locale_encode ($string)" 4
.IX Item "$octets = $term->locale_encode ($string)"
Convert the given text string into the corresponding locale encoding.
.ie n .IP "$string = $term\->locale_decode ($octets)" 4
.el .IP "$string = \f(CW$term\fR\->locale_decode ($octets)" 4
.IX Item "$string = $term->locale_decode ($octets)"
Convert the given locale-encoded octets into a perl string.
.ie n .IP "$term\->scr_xor_span ($beg_row, $beg_col\fR, \f(CW$end_row\fR, \f(CW$end_col\fR[, \f(CW$rstyle])" 4
.el .IP "$term\->scr_xor_span ($beg_row, \f(CW$beg_col\fR, \f(CW$end_row\fR, \f(CW$end_col\fR[, \f(CW$rstyle\fR])" 4
.IX Item "$term->scr_xor_span ($beg_row, $beg_col, $end_row, $end_col[, $rstyle])"
XORs the rendition values in the given span with the provided value
(default: \f(CW\*(C`RS_RVid\*(C'\fR), which \fI\s-1MUST\s0 \s-1NOT\s0\fR contain font styles. Useful in
refresh hooks to provide effects similar to the selection.
.ie n .IP "$term\->scr_xor_rect ($beg_row, $beg_col\fR, \f(CW$end_row\fR, \f(CW$end_col\fR[, \f(CW$rstyle1\fR[, \f(CW$rstyle2]])" 4
.el .IP "$term\->scr_xor_rect ($beg_row, \f(CW$beg_col\fR, \f(CW$end_row\fR, \f(CW$end_col\fR[, \f(CW$rstyle1\fR[, \f(CW$rstyle2\fR]])" 4
.IX Item "$term->scr_xor_rect ($beg_row, $beg_col, $end_row, $end_col[, $rstyle1[, $rstyle2]])"
Similar to \f(CW\*(C`scr_xor_span\*(C'\fR, but xors a rectangle instead. Trailing
whitespace will additionally be xored with the \f(CW$rstyle2\fR, which defaults
to \f(CW\*(C`RS_RVid | RS_Uline\*(C'\fR, which removes reverse video again and underlines
it instead. Both styles \fI\s-1MUST\s0 \s-1NOT\s0\fR contain font styles.
.IP "$term\->scr_bell" 4
.IX Item "$term->scr_bell"
Ring the bell!
.IP "$term\->scr_add_lines ($string)" 4
.IX Item "$term->scr_add_lines ($string)"
Write the given text string to the screen, as if output by the application
running inside the terminal. It may not contain command sequences (escape
codes), but is free to use line feeds, carriage returns and tabs. The
string is a normal text string, not in locale-dependent encoding.
.Sp
Normally its not a good idea to use this function, as programs might be
confused by changes in cursor position or scrolling. Its useful inside a
\&\f(CW\*(C`on_add_lines\*(C'\fR hook, though.
.IP "$term\->cmd_parse ($octets)" 4
.IX Item "$term->cmd_parse ($octets)"
Similar to \f(CW\*(C`scr_add_lines\*(C'\fR, but the argument must be in the
locale-specific encoding of the terminal and can contain command sequences
(escape codes) that will be interpreted.
.IP "$term\->tt_write ($octets)" 4
.IX Item "$term->tt_write ($octets)"
Write the octets given in \f(CW$data\fR to the tty (i.e. as program input). To
pass characters instead of octets, you should convert your strings first
to the locale-specific encoding using \f(CW\*(C`$term\->locale_encode\*(C'\fR.
.ie n .IP "$old_events = $term\->pty_ev_events ([$new_events])" 4
.el .IP "$old_events = \f(CW$term\fR\->pty_ev_events ([$new_events])" 4
.IX Item "$old_events = $term->pty_ev_events ([$new_events])"
Replaces the event mask of the pty watcher by the given event mask. Can
be used to suppress input and output handling to the pty/tty. See the
description of \f(CW\*(C`urxvt::timer\->events\*(C'\fR. Make sure to always restore
the previous value.
.ie n .IP "$windowid = $term\->parent" 4
.el .IP "$windowid = \f(CW$term\fR\->parent" 4
.IX Item "$windowid = $term->parent"
Return the window id of the toplevel window.
.ie n .IP "$windowid = $term\->vt" 4
.el .IP "$windowid = \f(CW$term\fR\->vt" 4
.IX Item "$windowid = $term->vt"
Return the window id of the terminal window.
.IP "$term\->vt_emask_add ($x_event_mask)" 4
.IX Item "$term->vt_emask_add ($x_event_mask)"
Adds the specified events to the vt event mask. Useful e.g. when you want
to receive pointer events all the times:
.Sp
.Vb 1
\&   $term->vt_emask_add (urxvt::PointerMotionMask);
.Ve
.ie n .IP "$window_width = $term\->width" 4
.el .IP "$window_width = \f(CW$term\fR\->width" 4
.IX Item "$window_width = $term->width"
.PD 0
.ie n .IP "$window_height = $term\->height" 4
.el .IP "$window_height = \f(CW$term\fR\->height" 4
.IX Item "$window_height = $term->height"
.ie n .IP "$font_width = $term\->fwidth" 4
.el .IP "$font_width = \f(CW$term\fR\->fwidth" 4
.IX Item "$font_width = $term->fwidth"
.ie n .IP "$font_height = $term\->fheight" 4
.el .IP "$font_height = \f(CW$term\fR\->fheight" 4
.IX Item "$font_height = $term->fheight"
.ie n .IP "$font_ascent = $term\->fbase" 4
.el .IP "$font_ascent = \f(CW$term\fR\->fbase" 4
.IX Item "$font_ascent = $term->fbase"
.ie n .IP "$terminal_rows = $term\->nrow" 4
.el .IP "$terminal_rows = \f(CW$term\fR\->nrow" 4
.IX Item "$terminal_rows = $term->nrow"
.ie n .IP "$terminal_columns = $term\->ncol" 4
.el .IP "$terminal_columns = \f(CW$term\fR\->ncol" 4
.IX Item "$terminal_columns = $term->ncol"
.ie n .IP "$has_focus = $term\->focus" 4
.el .IP "$has_focus = \f(CW$term\fR\->focus" 4
.IX Item "$has_focus = $term->focus"
.ie n .IP "$is_mapped = $term\->mapped" 4
.el .IP "$is_mapped = \f(CW$term\fR\->mapped" 4
.IX Item "$is_mapped = $term->mapped"
.ie n .IP "$max_scrollback = $term\->saveLines" 4
.el .IP "$max_scrollback = \f(CW$term\fR\->saveLines" 4
.IX Item "$max_scrollback = $term->saveLines"
.ie n .IP "$nrow_plus_saveLines = $term\->total_rows" 4
.el .IP "$nrow_plus_saveLines = \f(CW$term\fR\->total_rows" 4
.IX Item "$nrow_plus_saveLines = $term->total_rows"
.ie n .IP "$lines_in_scrollback = $term\->nsaved" 4
.el .IP "$lines_in_scrollback = \f(CW$term\fR\->nsaved" 4
.IX Item "$lines_in_scrollback = $term->nsaved"
.PD
Return various integers describing terminal characteristics.
.ie n .IP "$x_display = $term\->display_id" 4
.el .IP "$x_display = \f(CW$term\fR\->display_id" 4
.IX Item "$x_display = $term->display_id"
Return the \s-1DISPLAY\s0 used by rxvt\-unicode.
.ie n .IP "$lc_ctype = $term\->locale" 4
.el .IP "$lc_ctype = \f(CW$term\fR\->locale" 4
.IX Item "$lc_ctype = $term->locale"
Returns the \s-1LC_CTYPE\s0 category string used by this rxvt\-unicode.
.ie n .IP "$env = $term\->env" 4
.el .IP "$env = \f(CW$term\fR\->env" 4
.IX Item "$env = $term->env"
Returns a copy of the environment in effect for the terminal as a hashref
similar to \f(CW\*(C`\e%ENV\*(C'\fR.
.ie n .IP "$modifiermask = $term\->ModLevel3Mask" 4
.el .IP "$modifiermask = \f(CW$term\fR\->ModLevel3Mask" 4
.IX Item "$modifiermask = $term->ModLevel3Mask"
.PD 0
.ie n .IP "$modifiermask = $term\->ModMetaMask" 4
.el .IP "$modifiermask = \f(CW$term\fR\->ModMetaMask" 4
.IX Item "$modifiermask = $term->ModMetaMask"
.ie n .IP "$modifiermask = $term\->ModNumLockMask" 4
.el .IP "$modifiermask = \f(CW$term\fR\->ModNumLockMask" 4
.IX Item "$modifiermask = $term->ModNumLockMask"
.PD
Return the modifier masks corresponding to the \*(L"\s-1ISO\s0 Level 3 Shift\*(R" (often
AltGr), the meta key (often Alt) and the num lock key, if applicable.
.ie n .IP "$view_start = $term\->view_start ([$newvalue])" 4
.el .IP "$view_start = \f(CW$term\fR\->view_start ([$newvalue])" 4
.IX Item "$view_start = $term->view_start ([$newvalue])"
Returns the negative row number of the topmost line. Minimum value is
\&\f(CW0\fR, which displays the normal terminal contents. Larger values scroll
this many lines into the scrollback buffer.
.IP "$term\->want_refresh" 4
.IX Item "$term->want_refresh"
Requests a screen refresh. At the next opportunity, rxvt-unicode will
compare the on-screen display with its stored representation. If they
differ, it redraws the differences.
.Sp
Used after changing terminal contents to display them.
.ie n .IP "$text = $term\fR\->ROW_t ($row_number[, \f(CW$new_text\fR[, \f(CW$start_col]])" 4
.el .IP "$text = \f(CW$term\fR\->ROW_t ($row_number[, \f(CW$new_text\fR[, \f(CW$start_col\fR]])" 4
.IX Item "$text = $term->ROW_t ($row_number[, $new_text[, $start_col]])"
Returns the text of the entire row with number \f(CW$row_number\fR. Row \f(CW0\fR
is the topmost terminal line, row \f(CW\*(C`$term\->$ncol\-1\*(C'\fR is the bottommost
terminal line. The scrollback buffer starts at line \f(CW\*(C`\-1\*(C'\fR and extends to
line \f(CW\*(C`\-$term\->nsaved\*(C'\fR. Nothing will be returned if a nonexistent line
is requested.
.Sp
If \f(CW$new_text\fR is specified, it will replace characters in the current
line, starting at column \f(CW$start_col\fR (default \f(CW0\fR), which is useful
to replace only parts of a line. The font index in the rendition will
automatically be updated.
.Sp
\&\f(CW$text\fR is in a special encoding: tabs and wide characters that use more
than one cell when displayed are padded with urxvt::NOCHAR characters
(\f(CW\*(C`chr 65535\*(C'\fR). Characters with combining characters and other characters
that do not fit into the normal tetx encoding will be replaced with
characters in the private use area.
.Sp
You have to obey this encoding when changing text. The advantage is
that \f(CW\*(C`substr\*(C'\fR and similar functions work on screen cells and not on
characters.
.Sp
The methods \f(CW\*(C`$term\->special_encode\*(C'\fR and \f(CW\*(C`$term\->special_decode\*(C'\fR
can be used to convert normal strings into this encoding and vice versa.
.ie n .IP "$rend = $term\fR\->ROW_r ($row_number[, \f(CW$new_rend\fR[, \f(CW$start_col]])" 4
.el .IP "$rend = \f(CW$term\fR\->ROW_r ($row_number[, \f(CW$new_rend\fR[, \f(CW$start_col\fR]])" 4
.IX Item "$rend = $term->ROW_r ($row_number[, $new_rend[, $start_col]])"
Like \f(CW\*(C`$term\->ROW_t\*(C'\fR, but returns an arrayref with rendition
bitsets. Rendition bitsets contain information about colour, font, font
styles and similar information. See also \f(CW\*(C`$term\->ROW_t\*(C'\fR.
.Sp
When setting rendition, the font mask will be ignored.
.Sp
See the section on \s-1RENDITION\s0, above.
.ie n .IP "$length = $term\fR\->ROW_l ($row_number[, \f(CW$new_length])" 4
.el .IP "$length = \f(CW$term\fR\->ROW_l ($row_number[, \f(CW$new_length\fR])" 4
.IX Item "$length = $term->ROW_l ($row_number[, $new_length])"
Returns the number of screen cells that are in use (\*(L"the line
length\*(R"). Unlike the urxvt core, this returns \f(CW\*(C`$term\->ncol\*(C'\fR if the
line is joined with the following one.
.ie n .IP "$bool = $term\->is_longer ($row_number)" 4
.el .IP "$bool = \f(CW$term\fR\->is_longer ($row_number)" 4
.IX Item "$bool = $term->is_longer ($row_number)"
Returns true if the row is part of a multiple-row logical \*(L"line\*(R" (i.e.
joined with the following row), which means all characters are in use
and it is continued on the next row (and possibly a continuation of the
previous row(s)).
.ie n .IP "$line = $term\->line ($row_number)" 4
.el .IP "$line = \f(CW$term\fR\->line ($row_number)" 4
.IX Item "$line = $term->line ($row_number)"
Create and return a new \f(CW\*(C`urxvt::line\*(C'\fR object that stores information
about the logical line that row \f(CW$row_number\fR is part of. It supports the
following methods:
.RS 4
.ie n .IP "$text = $line\->t ([$new_text])" 4
.el .IP "$text = \f(CW$line\fR\->t ([$new_text])" 4
.IX Item "$text = $line->t ([$new_text])"
Returns or replaces the full text of the line, similar to \f(CW\*(C`ROW_t\*(C'\fR
.ie n .IP "$rend = $line\->r ([$new_rend])" 4
.el .IP "$rend = \f(CW$line\fR\->r ([$new_rend])" 4
.IX Item "$rend = $line->r ([$new_rend])"
Returns or replaces the full rendition array of the line, similar to \f(CW\*(C`ROW_r\*(C'\fR
.ie n .IP "$length = $line\->l" 4
.el .IP "$length = \f(CW$line\fR\->l" 4
.IX Item "$length = $line->l"
Returns the length of the line in cells, similar to \f(CW\*(C`ROW_l\*(C'\fR.
.ie n .IP "$rownum = $line\->beg" 4
.el .IP "$rownum = \f(CW$line\fR\->beg" 4
.IX Item "$rownum = $line->beg"
.PD 0
.ie n .IP "$rownum = $line\->end" 4
.el .IP "$rownum = \f(CW$line\fR\->end" 4
.IX Item "$rownum = $line->end"
.PD
Return the row number of the first/last row of the line, respectively.
.ie n .IP "$offset = $line\fR\->offset_of ($row, \f(CW$col)" 4
.el .IP "$offset = \f(CW$line\fR\->offset_of ($row, \f(CW$col\fR)" 4
.IX Item "$offset = $line->offset_of ($row, $col)"
Returns the character offset of the given row|col pair within the logical
line. Works for rows outside the line, too, and returns corresponding
offsets outside the string.
.ie n .IP "($row, $col\fR) = \f(CW$line\->coord_of ($offset)" 4
.el .IP "($row, \f(CW$col\fR) = \f(CW$line\fR\->coord_of ($offset)" 4
.IX Item "($row, $col) = $line->coord_of ($offset)"
Translates a string offset into terminal coordinates again.
.RE
.RS 4
.RE
.ie n .IP "$text = $term\fR\->special_encode \f(CW$string" 4
.el .IP "$text = \f(CW$term\fR\->special_encode \f(CW$string\fR" 4
.IX Item "$text = $term->special_encode $string"
Converts a perl string into the special encoding used by rxvt\-unicode,
where one character corresponds to one screen cell. See
\&\f(CW\*(C`$term\->ROW_t\*(C'\fR for details.
.ie n .IP "$string = $term\fR\->special_decode \f(CW$text" 4
.el .IP "$string = \f(CW$term\fR\->special_decode \f(CW$text\fR" 4
.IX Item "$string = $term->special_decode $text"
Converts rxvt-unicodes text reprsentation into a perl string. See
\&\f(CW\*(C`$term\->ROW_t\*(C'\fR for details.
.ie n .IP "$success = $term\fR\->grab_button ($button, \f(CW$modifiermask)" 4
.el .IP "$success = \f(CW$term\fR\->grab_button ($button, \f(CW$modifiermask\fR)" 4
.IX Item "$success = $term->grab_button ($button, $modifiermask)"
Registers a synchronous button grab. See the XGrabButton manpage.
.ie n .IP "$success = $term\fR\->grab ($eventtime[, \f(CW$sync])" 4
.el .IP "$success = \f(CW$term\fR\->grab ($eventtime[, \f(CW$sync\fR])" 4
.IX Item "$success = $term->grab ($eventtime[, $sync])"
Calls XGrabPointer and XGrabKeyboard in asynchronous (default) or
synchronous (\f(CW$sync\fR is true). Also remembers the grab timestampe.
.IP "$term\->allow_events_async" 4
.IX Item "$term->allow_events_async"
Calls XAllowEvents with AsyncBoth for the most recent grab.
.IP "$term\->allow_events_sync" 4
.IX Item "$term->allow_events_sync"
Calls XAllowEvents with SyncBoth for the most recent grab.
.IP "$term\->allow_events_replay" 4
.IX Item "$term->allow_events_replay"
Calls XAllowEvents with both ReplayPointer and ReplayKeyboard for the most
recent grab.
.IP "$term\->ungrab" 4
.IX Item "$term->ungrab"
Calls XUngrab for the most recent grab. Is called automatically on
evaluation errors, as it is better to lose the grab in the error case as
the session.
.ie n .Sh "The ""urxvt::popup"" Class"
.el .Sh "The \f(CWurxvt::popup\fP Class"
.IX Subsection "The urxvt::popup Class"
.IP "$popup\->add_title ($title)" 4
.IX Item "$popup->add_title ($title)"
Adds a non-clickable title to the popup.
.IP "$popup\->add_separator ([$sepchr])" 4
.IX Item "$popup->add_separator ([$sepchr])"
Creates a separator, optionally using the character given as \f(CW$sepchr\fR.
.ie n .IP "$popup\->add_button ($text, $cb)" 4
.el .IP "$popup\->add_button ($text, \f(CW$cb\fR)" 4
.IX Item "$popup->add_button ($text, $cb)"
Adds a clickable button to the popup. \f(CW$cb\fR is called whenever it is
selected.
.ie n .IP "$popup\->add_toggle ($text, $cb\fR, \f(CW$initial_value)" 4
.el .IP "$popup\->add_toggle ($text, \f(CW$cb\fR, \f(CW$initial_value\fR)" 4
.IX Item "$popup->add_toggle ($text, $cb, $initial_value)"
Adds a toggle/checkbox item to the popup. Teh callback gets called
whenever it gets toggled, with a boolean indicating its value as its first
argument.
.IP "$popup\->show" 4
.IX Item "$popup->show"
Displays the popup (which is initially hidden).
.ie n .Sh "The ""urxvt::timer"" Class"
.el .Sh "The \f(CWurxvt::timer\fP Class"
.IX Subsection "The urxvt::timer Class"
This class implements timer watchers/events. Time is represented as a
fractional number of seconds since the epoch. Example:
.PP
.Vb 8
\&   $term->{overlay} = $term->overlay (-1, 0, 8, 1, urxvt::OVERLAY_RSTYLE, 0);
\&   $term->{timer} = urxvt::timer
\&                    ->new
\&                    ->interval (1)
\&                    ->cb (sub {
\&                       $term->{overlay}->set (0, 0,
\&                          sprintf "%2d:%02d:%02d", (localtime urxvt::NOW)[2,1,0]);
\&                    });
.Ve
.IP "$timer = new urxvt::timer" 4
.IX Item "$timer = new urxvt::timer"
Create a new timer object in started state. It is scheduled to fire
immediately.
.ie n .IP "$timer = $timer\fR\->cb (sub { my ($timer) = \f(CW@_; ... })" 4
.el .IP "$timer = \f(CW$timer\fR\->cb (sub { my ($timer) = \f(CW@_\fR; ... })" 4
.IX Item "$timer = $timer->cb (sub { my ($timer) = @_; ... })"
Set the callback to be called when the timer triggers.
.ie n .IP "$tstamp = $timer\->at" 4
.el .IP "$tstamp = \f(CW$timer\fR\->at" 4
.IX Item "$tstamp = $timer->at"
Return the time this watcher will fire next.
.ie n .IP "$timer = $timer\->set ($tstamp)" 4
.el .IP "$timer = \f(CW$timer\fR\->set ($tstamp)" 4
.IX Item "$timer = $timer->set ($tstamp)"
Set the time the event is generated to \f(CW$tstamp\fR.
.ie n .IP "$timer = $timer\->interval ($interval)" 4
.el .IP "$timer = \f(CW$timer\fR\->interval ($interval)" 4
.IX Item "$timer = $timer->interval ($interval)"
Normally (and when \f(CW$interval\fR is \f(CW0\fR), the timer will automatically
stop after it has fired once. If \f(CW$interval\fR is non\-zero, then the timer
is automatically rescheduled at the given intervals.
.ie n .IP "$timer = $timer\->start" 4
.el .IP "$timer = \f(CW$timer\fR\->start" 4
.IX Item "$timer = $timer->start"
Start the timer.
.ie n .IP "$timer = $timer\->start ($tstamp)" 4
.el .IP "$timer = \f(CW$timer\fR\->start ($tstamp)" 4
.IX Item "$timer = $timer->start ($tstamp)"
Set the event trigger time to \f(CW$tstamp\fR and start the timer.
.ie n .IP "$timer = $timer\->stop" 4
.el .IP "$timer = \f(CW$timer\fR\->stop" 4
.IX Item "$timer = $timer->stop"
Stop the timer.
.ie n .Sh "The ""urxvt::iow"" Class"
.el .Sh "The \f(CWurxvt::iow\fP Class"
.IX Subsection "The urxvt::iow Class"
This class implements io watchers/events. Example:
.PP
.Vb 12
\&  $term->{socket} = ...
\&  $term->{iow} = urxvt::iow
\&                 ->new
\&                 ->fd (fileno $term->{socket})
\&                 ->events (urxvt::EVENT_READ)
\&                 ->start
\&                 ->cb (sub {
\&                   my ($iow, $revents) = @_;
\&                   # $revents must be 1 here, no need to check
\&                   sysread $term->{socket}, my $buf, 8192
\&                      or end-of-file;
\&                 });
.Ve
.IP "$iow = new urxvt::iow" 4
.IX Item "$iow = new urxvt::iow"
Create a new io watcher object in stopped state.
.ie n .IP "$iow = $iow\fR\->cb (sub { my ($iow, \f(CW$reventmask\fR) = \f(CW@_; ... })" 4
.el .IP "$iow = \f(CW$iow\fR\->cb (sub { my ($iow, \f(CW$reventmask\fR) = \f(CW@_\fR; ... })" 4
.IX Item "$iow = $iow->cb (sub { my ($iow, $reventmask) = @_; ... })"
Set the callback to be called when io events are triggered. \f(CW$reventmask\fR
is a bitset as described in the \f(CW\*(C`events\*(C'\fR method.
.ie n .IP "$iow = $iow\->fd ($fd)" 4
.el .IP "$iow = \f(CW$iow\fR\->fd ($fd)" 4
.IX Item "$iow = $iow->fd ($fd)"
Set the filedescriptor (not handle) to watch.
.ie n .IP "$iow = $iow\->events ($eventmask)" 4
.el .IP "$iow = \f(CW$iow\fR\->events ($eventmask)" 4
.IX Item "$iow = $iow->events ($eventmask)"
Set the event mask to watch. The only allowed values are
\&\f(CW\*(C`urxvt::EVENT_READ\*(C'\fR and \f(CW\*(C`urxvt::EVENT_WRITE\*(C'\fR, which might be ORed
together, or \f(CW\*(C`urxvt::EVENT_NONE\*(C'\fR.
.ie n .IP "$iow = $iow\->start" 4
.el .IP "$iow = \f(CW$iow\fR\->start" 4
.IX Item "$iow = $iow->start"
Start watching for requested events on the given handle.
.ie n .IP "$iow = $iow\->stop" 4
.el .IP "$iow = \f(CW$iow\fR\->stop" 4
.IX Item "$iow = $iow->stop"
Stop watching for events on the given filehandle.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
.Sh "\s-1URXVT_PERL_VERBOSITY\s0"
.IX Subsection "URXVT_PERL_VERBOSITY"
This variable controls the verbosity level of the perl extension. Higher
numbers indicate more verbose output.
.IP "== 0 \- fatal messages" 4
.IX Item "== 0 - fatal messages"
.PD 0
.IP ">= 3 \- script loading and management" 4
.IX Item ">= 3 - script loading and management"
.IP ">=10 \- all called hooks" 4
.IX Item ">=10 - all called hooks"
.IP ">=11 \- hook reutrn values" 4
.IX Item ">=11 - hook reutrn values"
.PD
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\& Marc Lehmann <pcg@goof.com>
\& http://software.schmorp.de/pkg/rxvt-unicode
.Ve
