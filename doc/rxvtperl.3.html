<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>rxvtperl - rxvt-unicode's embedded perl interpreter</title>
<link rev="made" href="mailto:perl-binary@plan9.de" />
</head>

<body style="background-color: white">

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<ul>

		<li><a href="#prepackaged_extensions">Prepackaged Extensions</a></li>
		<li><a href="#general_api_considerations">General API Considerations</a></li>
		<li><a href="#hooks">Hooks</a></li>
		<li><a href="#variables_in_the_urxvt_package">Variables in the <code>urxvt</code> Package</a></li>
		<li><a href="#functions_in_the_urxvt_package">Functions in the <code>urxvt</code> Package</a></li>
		<li><a href="#rendition">RENDITION</a></li>
		<li><a href="#the_urxvt__term_class">The <code>urxvt::term</code> Class</a></li>
		<li><a href="#the_urxvt__timer_class">The <code>urxvt::timer</code> Class</a></li>
		<li><a href="#the_urxvt__iow_class">The <code>urxvt::iow</code> Class</a></li>
	</ul>

	<li><a href="#environment">ENVIRONMENT</a></li>
	<ul>

		<li><a href="#urxvt_perl_verbosity">URXVT_PERL_VERBOSITY</a></li>
	</ul>

	<li><a href="#author">AUTHOR</a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<hr />
<h1><a name="name">NAME</a></h1>
<p>rxvtperl - rxvt-unicode's embedded perl interpreter</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
   # create a file grab_test in $HOME:</pre>
<pre>
   sub on_sel_grab {
      warn &quot;you selected &quot;, $_[0]-&gt;selection;
      ()
   }</pre>
<pre>
   # start a rxvt using it:</pre>
<pre>
   rxvt --perl-lib $HOME -pe grab_test</pre>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>Everytime a terminal object gets created, scripts specified via the
<code>perl</code> resource are loaded and associated with it.</p>
<p>Scripts are compiled in a 'use strict' and 'use utf8' environment, and
thus must be encoded as UTF-8.</p>
<p>Each script will only ever be loaded once, even in rxvtd, where
scripts will be shared (but not enabled) for all terminals.</p>
<p>
</p>
<h2><a name="prepackaged_extensions">Prepackaged Extensions</a></h2>
<p>This section describes the extensiosn delivered with this version. You can
find them in <em>/opt/rxvt/lib/urxvt/perl/</em>.</p>
<p>You can activate them like this:</p>
<pre>
  rxvt -pe &lt;extensionname&gt;</pre>
<dl>
<dt><strong><a name="item_selection">selection</a></strong><br />
</dt>
<dd>
Intelligent selection. This extension tries to be more intelligent when
the user extends selections (double-click). Right now, it tries to select
urls and complete shell-quoted arguments, which is very convenient, too,
if your <em>ls</em> supports <code>--quoting-style=shell</code>.
</dd>
<dd>
<p>It also offers the following bindable event:</p>
</dd>
<dl>
<dt><strong><a name="item_rot13">rot13</a></strong><br />
</dt>
<dd>
Rot-13 the selection when activated. Used via keyboard trigger:
</dd>
<dd>
<pre>
   URxvt.keysym.C-M-r: perl:selection:rot13</pre>
</dd>
<p></p></dl>
<dt><strong><a name="item_digital_2dclock">digital-clock</a></strong><br />
</dt>
<dd>
Displays a digital clock using the built-in overlay.
</dd>
<p></p>
<dt><strong><a name="item_example_2drefresh_2dhooks">example-refresh-hooks</a></strong><br />
</dt>
<dd>
Displays a very simple digital clock in the upper right corner of the
window. Illustrates overwriting the refresh callbacks to create your own
overlays or changes.
</dd>
<p></p></dl>
<p>
</p>
<h2><a name="general_api_considerations">General API Considerations</a></h2>
<p>All objects (such as terminals, time watchers etc.) are typical
reference-to-hash objects. The hash can be used to store anything you
like. All members starting with an underscore (such as <code>_ptr</code> or
<code>_hook</code>) are reserved for internal uses and <strong>MUST NOT</strong> be accessed or
modified).</p>
<p>When objects are destroyed on the C++ side, the perl object hashes are
emptied, so its best to store related objects such as time watchers and
the like inside the terminal object so they get destroyed as soon as the
terminal is destroyed.</p>
<p>
</p>
<h2><a name="hooks">Hooks</a></h2>
<p>The following subroutines can be declared in loaded scripts, and will be
called whenever the relevant event happens.</p>
<p>The first argument passed to them is an object private to each terminal
and extension package.  You can call all <code>urxvt::term</code> methods on it, but
its not a real <code>urxvt::term</code> object. Instead, the real <code>urxvt::term</code>
object that is shared between all packages is stored in the <code>term</code>
member.</p>
<p>All of them must return a boolean value. If it is true, then the event
counts as being <em>consumed</em>, and the invocation of other hooks is skipped,
and the relevant action might not be carried out by the C++ code.</p>
<p>When in doubt, return a false value (preferably <code>()</code>).</p>
<dl>
<dt><strong><a name="item_on_init__24term">on_init $term</a></strong><br />
</dt>
<dd>
Called after a new terminal object has been initialized, but before
windows are created or the command gets run.
</dd>
<p></p>
<dt><strong><a name="item_on_reset__24term">on_reset $term</a></strong><br />
</dt>
<dd>
Called after the screen is ``reset'' for any reason, such as resizing or
control sequences. Here is where you can react on changes to size-related
variables.
</dd>
<p></p>
<dt><strong><a name="item_on_start__24term">on_start $term</a></strong><br />
</dt>
<dd>
Called at the very end of initialisation of a new terminal, just before
returning to the mainloop.
</dd>
<p></p>
<dt><strong><a name="item_on_sel_make__24term_2c__24eventtime">on_sel_make $term, $eventtime</a></strong><br />
</dt>
<dd>
Called whenever a selection has been made by the user, but before the
selection text is copied, so changes to the beginning, end or type of the
selection will be honored.
</dd>
<dd>
<p>Returning a true value aborts selection making by urxvt, in which case you
have to make a selection yourself by calling <a href="#item_selection_grab"><code>$term-&gt;selection_grab</code></a>.</p>
</dd>
<p></p>
<dt><strong><a name="item_on_sel_grab__24term_2c__24eventtime">on_sel_grab $term, $eventtime</a></strong><br />
</dt>
<dd>
Called whenever a selection has been copied, but before the selection is
requested from the server.  The selection text can be queried and changed
by calling <a href="#item_selection"><code>$term-&gt;selection</code></a>.
</dd>
<dd>
<p>Returning a true value aborts selection grabbing. It will still be hilighted.</p>
</dd>
<p></p>
<dt><strong><a name="item_on_sel_extend__24term">on_sel_extend $term</a></strong><br />
</dt>
<dd>
Called whenever the user tries to extend the selection (e.g. with a double
click) and is either supposed to return false (normal operation), or
should extend the selection itelf and return true to suppress the built-in
processing.
</dd>
<dd>
<p>See the <em>selection</em> example extension.</p>
</dd>
<p></p>
<dt><strong><a name="item_on_focus_in__24term">on_focus_in $term</a></strong><br />
</dt>
<dd>
Called whenever the window gets the keyboard focus, before urxvt does
focus in processing.
</dd>
<p></p>
<dt><strong><a name="item_on_focus_out__24term">on_focus_out $term</a></strong><br />
</dt>
<dd>
Called wheneever the window loses keyboard focus, before urxvt does focus
out processing.
</dd>
<p></p>
<dt><strong><a name="item_on_view_change__24term_2c__24offset">on_view_change $term, $offset</a></strong><br />
</dt>
<dd>
Called whenever the view offset changes, i..e the user or program
scrolls. Offset <code>0</code> means display the normal terminal, positive values
show this many lines of scrollback.
</dd>
<p></p>
<dt><strong><a name="item_on_scroll_back__24term_2c__24lines_2c__24saved">on_scroll_back $term, $lines, $saved</a></strong><br />
</dt>
<dd>
Called whenever lines scroll out of the terminal area into the scrollback
buffer. <code>$lines</code> is the number of lines scrolled out and may be larger
than the scroll back buffer or the terminal.
</dd>
<dd>
<p>It is called before lines are scrolled out (so rows 0 .. min ($lines - 1,
$nrow - 1) represent the lines to be scrolled out). <code>$saved</code> is the total
number of lines that will be in the scrollback buffer.</p>
</dd>
<p></p>
<dt><strong><a name="item_on_tty_activity__24term__2anyi_2a">on_tty_activity $term *NYI*</a></strong><br />
</dt>
<dd>
Called whenever the <code>program(s)</code> running in the urxvt window send output.
</dd>
<p></p>
<dt><strong><a name="item_on_osc_seq__24term_2c__24string">on_osc_seq $term, $string</a></strong><br />
</dt>
<dd>
Called whenever the <strong>ESC ] 777 ; string ST</strong> command sequence (OSC =
operating system command) is processed. Cursor position and other state
information is up-to-date when this happens. For interoperability, the
string should start with the extension name and a colon, to distinguish
it from commands for other extensions, and this might be enforced in the
future.
</dd>
<dd>
<p>Be careful not ever to trust (in a security sense) the data you receive,
as its source can not easily be controleld (e-mail content, messages from
other users on the same system etc.).</p>
</dd>
<p></p>
<dt><strong><a name="item_on_refresh_begin__24term">on_refresh_begin $term</a></strong><br />
</dt>
<dd>
Called just before the screen gets redrawn. Can be used for overlay
or similar effects by modify terminal contents in refresh_begin, and
restoring them in refresh_end. The built-in overlay and selection display
code is run after this hook, and takes precedence.
</dd>
<p></p>
<dt><strong><a name="item_on_refresh_end__24term">on_refresh_end $term</a></strong><br />
</dt>
<dd>
Called just after the screen gets redrawn. See <code>on_refresh_begin</code>.
</dd>
<p></p>
<dt><strong><a name="item_on_keyboard_command__24term_2c__24string">on_keyboard_command $term, $string</a></strong><br />
</dt>
<dd>
Called whenever the user presses a key combination that has a
<code>perl:string</code> action bound to it (see description of the <strong>keysym</strong>
resource in the <code>rxvt(1)</code> manpage).
</dd>
<p></p></dl>
<p>
</p>
<h2><a name="variables_in_the_urxvt_package">Variables in the <code>urxvt</code> Package</a></h2>
<dl>
<dt><strong><a name="item__24urxvt_3a_3aterm">$urxvt::TERM</a></strong><br />
</dt>
<dd>
The current terminal. Whenever a callback/Hook is bein executed, this
variable stores the current <code>urxvt::term</code> object.
</dd>
<p></p></dl>
<p>
</p>
<h2><a name="functions_in_the_urxvt_package">Functions in the <code>urxvt</code> Package</a></h2>
<dl>
<dt><strong><a name="item_urxvt_3a_3afatal__24errormessage">urxvt::fatal $errormessage</a></strong><br />
</dt>
<dd>
Fatally aborts execution with the given error message. Avoid at all
costs! The only time this is acceptable is when the terminal process
starts up.
</dd>
<p></p>
<dt><strong><a name="item_urxvt_3a_3awarn__24string">urxvt::warn $string</a></strong><br />
</dt>
<dd>
Calls <code>rxvt_warn</code> with the given string which should not include a
newline. The module also overwrites the <code>warn</code> builtin with a function
that calls this function.
</dd>
<dd>
<p>Using this function has the advantage that its output ends up in the
correct place, e.g. on stderr of the connecting urxvtc client.</p>
</dd>
<p></p>
<dt><strong><a name="item__24time__3d_urxvt_3a_3anow">$time = urxvt::NOW</a></strong><br />
</dt>
<dd>
Returns the ``current time'' (as per the event loop).
</dd>
<p></p></dl>
<p>
</p>
<h2><a name="rendition">RENDITION</a></h2>
<p>Rendition bitsets contain information about colour, font, font styles and
similar information for each screen cell.</p>
<p>The following ``macros'' deal with changes in rendition sets. You should
never just create a bitset, you should always modify an existing one,
as they contain important information required for correct operation of
rxvt-unicode.</p>
<dl>
<dt><strong><a name="item__24rend__3d_urxvt_3a_3adefault_rstyle">$rend = urxvt::DEFAULT_RSTYLE</a></strong><br />
</dt>
<dd>
Returns the default rendition, as used when the terminal is starting up or
being reset. Useful as a base to start when creating renditions.
</dd>
<p></p>
<dt><strong><a name="item__24rend__3d_urxvt_3a_3aoverlay_rstyle">$rend = urxvt::OVERLAY_RSTYLE</a></strong><br />
</dt>
<dd>
Return the rendition mask used for overlays by default.
</dd>
<p></p>
<dt><strong><a name="item__24rendbit__3d_urxvt_3a_3ars_bold_2c_rs_italic_2c_">$rendbit = urxvt::RS_Bold, RS_Italic, RS_Blink, RS_RVid, RS_Uline</a></strong><br />
</dt>
<dd>
Return the bit that enabled bold, italic, blink, reverse-video and
underline, respectively. To enable such a style, just logically OR it into
the bitset.
</dd>
<p></p>
<dt><strong><a name="item__24foreground__3d_urxvt_3a_3aget_basefg__24rend">$foreground = urxvt::GET_BASEFG $rend</a></strong><br />
</dt>
<dt><strong><a name="item__24background__3d_urxvt_3a_3aget_basebg__24rend">$background = urxvt::GET_BASEBG $rend</a></strong><br />
</dt>
<dd>
Return the foreground/background colour index, respectively.
</dd>
<p></p>
<dt><strong><a name="item_set_fgcolor">$rend = urxvt::SET_FGCOLOR ($rend, $new_colour)</a></strong><br />
</dt>
<dt><strong><a name="item_set_bgcolor">$rend = urxvt::SET_BGCOLOR ($rend, $new_colour)</a></strong><br />
</dt>
<dd>
Replace the foreground/background colour in the rendition mask with the
specified one.
</dd>
<p></p>
<dt><strong><a name="item_get_custom">$value = urxvt::GET_CUSTOM ($rend)</a></strong><br />
</dt>
<dd>
Return the ``custom'' value: Every rendition has 5 bits for use by
extensions. They can be set and changed as you like and are initially
zero.
</dd>
<p></p>
<dt><strong><a name="item_set_custom">$rend = urxvt::SET_CUSTOM ($rend, $new_value)</a></strong><br />
</dt>
<dd>
Change the custom value.
</dd>
<p></p></dl>
<p>
</p>
<h2><a name="the_urxvt__term_class">The <code>urxvt::term</code> Class</a></h2>
<dl>
<dt><strong><a name="item_resource">$value = $term-&gt;resource ($name[, $newval])</a></strong><br />
</dt>
<dd>
Returns the current resource value associated with a given name and
optionally sets a new value. Setting values is most useful in the <code>init</code>
hook. Unset resources are returned and accepted as <code>undef</code>.
</dd>
<dd>
<p>The new value must be properly encoded to a suitable character encoding
before passing it to this method. Similarly, the returned value may need
to be converted from the used encoding to text.</p>
</dd>
<dd>
<p>Resource names are as defined in <em>src/rsinc.h</em>. Colours can be specified
as resource names of the form <code>color+&lt;index&gt;</code>, e.g. <code>color+5</code>. (will
likely change).</p>
</dd>
<dd>
<p>Please note that resource strings will currently only be freed when the
terminal is destroyed, so changing options frequently will eat memory.</p>
</dd>
<dd>
<p>Here is a a likely non-exhaustive list of resource names, not all of which
are supported in every build, please see the source to see the actual
list:</p>
</dd>
<dd>
<pre>
  answerbackstring backgroundPixmap backspace_key boldFont boldItalicFont
  borderLess color cursorBlink cursorUnderline cutchars delete_key
  display_name embed ext_bwidth fade font geometry hold iconName
  imFont imLocale inputMethod insecure int_bwidth intensityStyles
  italicFont jumpScroll lineSpace loginShell mapAlert menu meta8 modifier
  mouseWheelScrollPage name pastableTabs path perl_eval perl_ext_1 perl_ext_2
  perl_lib pointerBlank pointerBlankDelay preeditType print_pipe pty_fd
  reverseVideo saveLines scrollBar scrollBar_align scrollBar_floating
  scrollBar_right scrollBar_thickness scrollTtyKeypress scrollTtyOutput
  scrollWithBuffer scrollstyle secondaryScreen secondaryScroll selectstyle
  shade term_name title transparent transparent_all tripleclickwords
  utmpInhibit visualBell</pre>
</dd>
<p></p>
<dt><strong><a name="item_screen_rstyle">$rend = $term-&gt;screen_rstyle ([$new_rstyle])</a></strong><br />
</dt>
<dd>
Return and optionally change the current rendition. Text thta is output by
the temrianl application will use this style.
</dd>
<p></p>
<dt><strong><a name="item_screen_cur">($row, $col) = $term-&gt;screen_cur ([$row, $col])</a></strong><br />
</dt>
<dd>
Return the current coordinates of the text cursor position and optionally
set it (which is usually bad as applications don't expect that).
</dd>
<p></p>
<dt><strong><a name="item_selection_mark">($row, $col) = $term-&gt;selection_mark ([$row, $col])</a></strong><br />
</dt>
<dt><strong><a name="item_selection_beg">($row, $col) = $term-&gt;selection_beg ([$row, $col])</a></strong><br />
</dt>
<dt><strong><a name="item_selection_end">($row, $col) = $term-&gt;selection_end ([$row, $col])</a></strong><br />
</dt>
<dd>
Return the current values of the selection mark, begin or end positions,
and optionally set them to new values.
</dd>
<p></p>
<dt><strong><a name="item_selection_grab">$success = $term-&gt;selection_grab ($eventtime)</a></strong><br />
</dt>
<dd>
Try to request the primary selection from the server (for example, as set
by the next method).
</dd>
<p></p>
<dt><strong>$oldtext = $term-&gt;selection ([$newtext])</strong><br />
</dt>
<dd>
Return the current selection text and optionally replace it by <code>$newtext</code>.
</dd>
<dd>
<p>#=item $term-&gt;overlay ($x, $y, $text)
#
#Create a simple multi-line overlay box. See the next method for details.
#
#=cut</p>
</dd>
<dd>
<p>sub urxvt::term::scr_overlay {
die;
   my ($self, $x, $y, $text) = @_;</p>
</dd>
<dd>
<pre>
   my @lines = split /\n/, $text;</pre>
</dd>
<dd>
<pre>
   my $w = 0;
   for (map $self-&gt;strwidth ($_), @lines) {
      $w = $_ if $w &lt; $_;
   }</pre>
</dd>
<dd>
<pre>
   $self-&gt;scr_overlay_new ($x, $y, $w, scalar @lines);
   $self-&gt;scr_overlay_set (0, $_, $lines[$_]) for 0.. $#lines;
}</pre>
</dd>
<p></p>
<dt><strong><a name="item_overlay">$term-&gt;overlay ($x, $y, $width, $height[, $rstyle[, $border]])</a></strong><br />
</dt>
<dd>
Create a new (empty) overlay at the given position with the given
width/height. <code>$rstyle</code> defines the initial rendition style
(default: <code>OVERLAY_RSTYLE</code>).
</dd>
<dd>
<p>If <code>$border</code> is <code>2</code> (default), then a decorative border will be put
around the box.</p>
</dd>
<dd>
<p>If either <code>$x</code> or <code>$y</code> is negative, then this is counted from the
right/bottom side, respectively.</p>
</dd>
<dd>
<p>This method returns an urxvt::overlay object. The overlay will be visible
as long as the perl object is referenced.</p>
</dd>
<dd>
<p>The methods currently supported on <code>urxvt::overlay</code> objects are:</p>
</dd>
<dl>
<dt><strong><a name="item_set">$overlay-&gt;set ($x, $y, $text, $rend)</a></strong><br />
</dt>
<dd>
Similar to <a href="#item_row_t"><code>$term-&gt;ROW_t</code></a> and <a href="#item_row_r"><code>$term-&gt;ROW_r</code></a> in that it puts
text in rxvt-unicode's special encoding and an array of rendition values
at a specific position inside the overlay.
</dd>
<p></p>
<dt><strong><a name="item_hide">$overlay-&gt;hide</a></strong><br />
</dt>
<dd>
If visible, hide the overlay, but do not destroy it.
</dd>
<p></p>
<dt><strong><a name="item_show">$overlay-&gt;show</a></strong><br />
</dt>
<dd>
If hidden, display the overlay again.
</dd>
<p></p></dl>
<dt><strong><a name="item_strwidth">$cellwidth = $term-&gt;strwidth $string</a></strong><br />
</dt>
<dd>
Returns the number of screen-cells this string would need. Correctly
accounts for wide and combining characters.
</dd>
<p></p>
<dt><strong><a name="item_locale_encode">$octets = $term-&gt;locale_encode $string</a></strong><br />
</dt>
<dd>
Convert the given text string into the corresponding locale encoding.
</dd>
<p></p>
<dt><strong><a name="item_locale_decode">$string = $term-&gt;locale_decode $octets</a></strong><br />
</dt>
<dd>
Convert the given locale-encoded octets into a perl string.
</dd>
<p></p>
<dt><strong><a name="item_tt_write">$term-&gt;tt_write ($octets)</a></strong><br />
</dt>
<dd>
Write the octets given in <code>$data</code> to the tty (i.e. as program input). To
pass characters instead of octets, you should convert your strings first
to the locale-specific encoding using <a href="#item_locale_encode"><code>$term-&gt;locale_encode</code></a>.
</dd>
<p></p>
<dt><strong><a name="item_width">$window_width = $term-&gt;width</a></strong><br />
</dt>
<dt><strong><a name="item_height">$window_height = $term-&gt;height</a></strong><br />
</dt>
<dt><strong><a name="item_fwidth">$font_width = $term-&gt;fwidth</a></strong><br />
</dt>
<dt><strong><a name="item_fheight">$font_height = $term-&gt;fheight</a></strong><br />
</dt>
<dt><strong><a name="item_fbase">$font_ascent = $term-&gt;fbase</a></strong><br />
</dt>
<dt><strong><a name="item_nrow">$terminal_rows = $term-&gt;nrow</a></strong><br />
</dt>
<dt><strong><a name="item_ncol">$terminal_columns = $term-&gt;ncol</a></strong><br />
</dt>
<dt><strong><a name="item_focus">$has_focus = $term-&gt;focus</a></strong><br />
</dt>
<dt><strong><a name="item_mapped">$is_mapped = $term-&gt;mapped</a></strong><br />
</dt>
<dt><strong><a name="item_savelines">$max_scrollback = $term-&gt;saveLines</a></strong><br />
</dt>
<dt><strong><a name="item_total_rows">$nrow_plus_saveLines = $term-&gt;total_rows</a></strong><br />
</dt>
<dt><strong><a name="item_nsaved">$lines_in_scrollback = $term-&gt;nsaved</a></strong><br />
</dt>
<dd>
Return various integers describing terminal characteristics.
</dd>
<p></p>
<dt><strong><a name="item_view_start">$view_start = $term-&gt;view_start ([$newvalue])</a></strong><br />
</dt>
<dd>
Returns the negative row number of the topmost line. Minimum value is
<code>0</code>, which displays the normal terminal contents. Larger values scroll
this many lines into the scrollback buffer.
</dd>
<p></p>
<dt><strong><a name="item_want_refresh">$term-&gt;want_refresh</a></strong><br />
</dt>
<dd>
Requests a screen refresh. At the next opportunity, rxvt-unicode will
compare the on-screen display with its stored representation. If they
differ, it redraws the differences.
</dd>
<dd>
<p>Used after changing terminal contents to display them.</p>
</dd>
<p></p>
<dt><strong><a name="item_row_t">$text = $term-&gt;ROW_t ($row_number[, $new_text[, $start_col]])</a></strong><br />
</dt>
<dd>
Returns the text of the entire row with number <code>$row_number</code>. Row <code>0</code>
is the topmost terminal line, row <code>$term-&gt;$ncol-1</code> is the bottommost
terminal line. The scrollback buffer starts at line <code>-1</code> and extends to
line <a href="#item_nsaved"><code>-$term-&gt;nsaved</code></a>. Nothing will be returned if a nonexistent line
is requested.
</dd>
<dd>
<p>If <code>$new_text</code> is specified, it will replace characters in the current
line, starting at column <code>$start_col</code> (default <code>0</code>), which is useful
to replace only parts of a line. The font index in the rendition will
automatically be updated.</p>
</dd>
<dd>
<p><code>$text</code> is in a special encoding: tabs and wide characters that use more
than one cell when displayed are padded with urxvt::NOCHAR characters
(<code>chr 65535</code>). Characters with combining characters and other characters
that do not fit into the normal tetx encoding will be replaced with
characters in the private use area.</p>
</dd>
<dd>
<p>You have to obey this encoding when changing text. The advantage is
that <code>substr</code> and similar functions work on screen cells and not on
characters.</p>
</dd>
<dd>
<p>The methods <code>$term-&gt;special_encode</code> and <a href="#item_special_decode"><code>$term-&gt;special_decode</code></a>
can be used to convert normal strings into this encoding and vice versa.</p>
</dd>
<p></p>
<dt><strong><a name="item_row_r">$rend = $term-&gt;ROW_r ($row_number[, $new_rend[, $start_col]])</a></strong><br />
</dt>
<dd>
Like <a href="#item_row_t"><code>$term-&gt;ROW_t</code></a>, but returns an arrayref with rendition
bitsets. Rendition bitsets contain information about colour, font, font
styles and similar information. See also <a href="#item_row_t"><code>$term-&gt;ROW_t</code></a>.
</dd>
<dd>
<p>When setting rendition, the font mask will be ignored.</p>
</dd>
<dd>
<p>See the section on RENDITION, above.</p>
</dd>
<p></p>
<dt><strong><a name="item_row_l">$length = $term-&gt;ROW_l ($row_number[, $new_length])</a></strong><br />
</dt>
<dd>
Returns the number of screen cells that are in use (``the line
length''). Unlike the urxvt core, this returns <a href="#item_ncol"><code>$term-&gt;ncol</code></a> if the
line is joined with the following one.
</dd>
<p></p>
<dt><strong><a name="item_is_longer">$bool = $term-&gt;is_longer ($row_number)</a></strong><br />
</dt>
<dd>
Returns true if the row is part of a multiple-row logical ``line'' (i.e.
joined with the following row), which means all characters are in use
and it is continued on the next row (and possibly a continuation of the
previous row(s)).
</dd>
<p></p>
<dt><strong><a name="item_line">$line = $term-&gt;line ($row_number)</a></strong><br />
</dt>
<dd>
Create and return a new <code>urxvt::line</code> object that stores information
about the logical line that row <code>$row_number</code> is part of. It supports the
following methods:
</dd>
<dl>
<dt><strong><a name="item_t">$text = $line-&gt;t</a></strong><br />
</dt>
<dd>
Returns the full text of the line, similar to <a href="#item_row_t"><code>ROW_t</code></a>
</dd>
<p></p>
<dt><strong><a name="item_r">$rend = $line-&gt;r</a></strong><br />
</dt>
<dd>
Returns the full rendition array of the line, similar to <a href="#item_row_r"><code>ROW_r</code></a>
</dd>
<p></p>
<dt><strong><a name="item_l">$length = $line-&gt;l</a></strong><br />
</dt>
<dd>
Returns the length of the line in cells, similar to <a href="#item_row_l"><code>ROW_l</code></a>.
</dd>
<p></p>
<dt><strong><a name="item_beg">$rownum = $line-&gt;beg</a></strong><br />
</dt>
<dt><strong><a name="item_end">$rownum = $line-&gt;end</a></strong><br />
</dt>
<dd>
Return the row number of the first/last row of the line, respectively.
</dd>
<p></p>
<dt><strong><a name="item_offset_of">$offset = $line-&gt;offset_of ($row, $col)</a></strong><br />
</dt>
<dd>
Returns the character offset of the given row|col pair within the logical
line.
</dd>
<p></p>
<dt><strong><a name="item_coord_of">($row, $col) = $line-&gt;coord_of ($offset)</a></strong><br />
</dt>
<dd>
Translates a string offset into terminal coordinates again.
</dd>
<p></p></dl>
<dt><strong>($row, $col) = $line-&gt;coord_of ($offset)
=item $text = $term-&gt;special_encode $string</strong><br />
</dt>
<dd>
Converts a perl string into the special encoding used by rxvt-unicode,
where one character corresponds to one screen cell. See
<a href="#item_row_t"><code>$term-&gt;ROW_t</code></a> for details.
</dd>
<p></p>
<dt><strong><a name="item_special_decode">$string = $term-&gt;special_decode $text</a></strong><br />
</dt>
<dd>
Converts rxvt-unicodes text reprsentation into a perl string. See
<a href="#item_row_t"><code>$term-&gt;ROW_t</code></a> for details.
</dd>
<p></p></dl>
<p>
</p>
<h2><a name="the_urxvt__timer_class">The <code>urxvt::timer</code> Class</a></h2>
<p>This class implements timer watchers/events. Time is represented as a
fractional number of seconds since the epoch. Example:</p>
<pre>
   $term-&gt;{overlay} = $term-&gt;overlay (-1, 0, 8, 1, urxvt::OVERLAY_RSTYLE, 0);
   $term-&gt;{timer} = urxvt::timer
                    -&gt;new
                    -&gt;interval (1)
                    -&gt;cb (sub {
                       $term-&gt;{overlay}-&gt;set (0, 0,
                          sprintf &quot;%2d:%02d:%02d&quot;, (localtime urxvt::NOW)[2,1,0]);
                    });</pre>
<dl>
<dt><strong><a name="item__24timer__3d_new_urxvt_3a_3atimer">$timer = new urxvt::timer</a></strong><br />
</dt>
<dd>
Create a new timer object in started state. It is scheduled to fire
immediately.
</dd>
<p></p>
<dt><strong><a name="item_cb">$timer = $timer-&gt;cb (sub { my ($timer) = @_; ... })</a></strong><br />
</dt>
<dd>
Set the callback to be called when the timer triggers.
</dd>
<p></p>
<dt><strong><a name="item_at">$tstamp = $timer-&gt;at</a></strong><br />
</dt>
<dd>
Return the time this watcher will fire next.
</dd>
<p></p>
<dt><strong>$timer = $timer-&gt;set ($tstamp)</strong><br />
</dt>
<dd>
Set the time the event is generated to $tstamp.
</dd>
<p></p>
<dt><strong><a name="item_interval">$timer = $timer-&gt;interval ($interval)</a></strong><br />
</dt>
<dd>
Normally (and when <code>$interval</code> is <code>0</code>), the timer will automatically
stop after it has fired once. If <code>$interval</code> is non-zero, then the timer
is automatically rescheduled at the given intervals.
</dd>
<p></p>
<dt><strong><a name="item_start">$timer = $timer-&gt;start</a></strong><br />
</dt>
<dd>
Start the timer.
</dd>
<p></p>
<dt><strong>$timer = $timer-&gt;start ($tstamp)</strong><br />
</dt>
<dd>
Set the event trigger time to <code>$tstamp</code> and start the timer.
</dd>
<p></p>
<dt><strong><a name="item_stop">$timer = $timer-&gt;stop</a></strong><br />
</dt>
<dd>
Stop the timer.
</dd>
<p></p></dl>
<p>
</p>
<h2><a name="the_urxvt__iow_class">The <code>urxvt::iow</code> Class</a></h2>
<p>This class implements io watchers/events. Example:</p>
<pre>
  $term-&gt;{socket} = ...
  $term-&gt;{iow} = urxvt::iow
                 -&gt;new
                 -&gt;fd (fileno $term-&gt;{socket})
                 -&gt;events (1) # wait for read data
                 -&gt;start
                 -&gt;cb (sub {
                   my ($iow, $revents) = @_;
                   # $revents must be 1 here, no need to check
                   sysread $term-&gt;{socket}, my $buf, 8192
                      or end-of-file;
                 });</pre>
<dl>
<dt><strong><a name="item__24iow__3d_new_urxvt_3a_3aiow">$iow = new urxvt::iow</a></strong><br />
</dt>
<dd>
Create a new io watcher object in stopped state.
</dd>
<p></p>
<dt><strong>$iow = $iow-&gt;cb (sub { my ($iow, $reventmask) = @_; ... })</strong><br />
</dt>
<dd>
Set the callback to be called when io events are triggered. <code>$reventmask</code>
is a bitset as described in the <a href="#item_events"><code>events</code></a> method.
</dd>
<p></p>
<dt><strong><a name="item_fd">$iow = $iow-&gt;fd ($fd)</a></strong><br />
</dt>
<dd>
Set the filedescriptor (not handle) to watch.
</dd>
<p></p>
<dt><strong><a name="item_events">$iow = $iow-&gt;events ($eventmask)</a></strong><br />
</dt>
<dd>
Set the event mask to watch. Bit #0 (value <code>1</code>) enables watching for read
data, Bit #1 (value <code>2</code>) enables watching for write data.
</dd>
<p></p>
<dt><strong>$iow = $iow-&gt;start</strong><br />
</dt>
<dd>
Start watching for requested events on the given handle.
</dd>
<p></p>
<dt><strong>$iow = $iow-&gt;stop</strong><br />
</dt>
<dd>
Stop watching for events on the given filehandle.
</dd>
<p></p></dl>
<p>
</p>
<hr />
<h1><a name="environment">ENVIRONMENT</a></h1>
<p>
</p>
<h2><a name="urxvt_perl_verbosity">URXVT_PERL_VERBOSITY</a></h2>
<p>This variable controls the verbosity level of the perl extension. Higher
numbers indicate more verbose output.</p>
<dl>
<dt><strong><a name="item__3d0__2d_only_fatal_messages">=0 - only fatal messages</a></strong><br />
</dt>
<dt><strong><a name="item__3d3__2d_script_loading_and_management">=3 - script loading and management</a></strong><br />
</dt>
<dt><strong><a name="item__3d10__2d_all_events_received">=10 - all events received</a></strong><br />
</dt>
</dl>
<p>
</p>
<hr />
<h1><a name="author">AUTHOR</a></h1>
<pre>
 Marc Lehmann &lt;pcg@goof.com&gt;
 <a href="http://software.schmorp.de/pkg/rxvt-unicode">http://software.schmorp.de/pkg/rxvt-unicode</a></pre>

</body>

</html>
