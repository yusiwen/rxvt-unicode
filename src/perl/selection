#! perl

sub on_keyboard_command {
   my ($self, $cmd) = @_;

   $cmd eq "selection:rot13"
      and $self->selection (map { y/A-Za-z/N-ZA-Mn-za-m/; $_ } $self->selection);

   ()
}

my @mark_patterns = (
   # urls, just a heuristic
   qr{(
      (?:https?|ftp|news|mailto|file)://[ab-zA-Z0-9\-\@;\/?:&=%\$_.+!*\x27(),~]+
      [ab-zA-Z0-9\-\@;\/?:&=%\$_+!*\x27(),~]   # do not include a trailing dot, its wrong too often
   )}x,

   # common forms of quoting
   qr{(?:^|\s) [‘`] ([^‘`’']+) [’'] (?:\s|$)}x,

   # shell-like argument quoting
   qr{\G [\ \t|&;<>()] *(
      (?:
         [^\\"'\ \t|&;<>()]+
         | \\.
         | " (?: [^\\"]+ | \\. )* "
         | ' [^']* '
      )+
   )}x,
);

my @simplify_patterns = (
   qr{^"([^\\"'\ \t|&;<>()*?]+)"$}, # "simple" => simple
   qr{^(.*)[,\-]$},
);

sub on_sel_extend {
   my ($self) = @_;

   my ($row, $col) = $self->selection_mark;
   my $line = $self->line ($row);
   my $offset = $line->offset_of ($row, $col);
   my $text = $line->t;

   for my $regex (@mark_patterns) {
      while ($text =~ /$regex/g) {
         if ($-[1] <= $offset and $offset <= $+[1]) {
            my $match = $1;
            my ($ofs1, $ofs2) = ($-[1], $+[1]);

            for my $regex (@simplify_patterns) {
               if ($match =~ $regex) {
                  $match = $1;
                  $ofs1 += $-[1];
                  $ofs2 = $ofs1 + length $match;
               }
            }

            $self->selection_beg ($line->coord_of ($ofs1));
            $self->selection_end ($line->coord_of ($ofs2));
            return 1;
         }
      }
   }

   ()
}
