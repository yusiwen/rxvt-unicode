#! perl

# this extension implements scrollback buffer search

sub on_init {
   my ($self) = @_;

   my $hotkey = $self->{argv}[0] || "M-s";

   $self->parse_keysym ($hotkey, "perl:searchable-scrollback:start")
      or warn "unable to register '$hotkey' as scrollback search start hotkey\n";

   ()
}

sub on_keyboard_command {
   my ($self, $cmd) = @_;

   if ($cmd eq "searchable-scrollback:start") {
      $self->enter;
   }

   ()
}

sub msg {
   my ($self, $msg) = @_;

   $self->{overlay} = $self->overlay (0, -1, $self->ncol, 1, urxvt::OVERLAY_RSTYLE, 0);
   $self->{overlay}->set (0, 0, $self->special_encode ($msg));
}

sub enter {
   my ($self) = @_;

   return if $self->{overlay};

   $self->{pty_ev_events} = $self->pty_ev_events (urxvt::EVENT_NONE);
   $self->{view_start} = $self->view_start;

   $self->enable (
      key_press     => \&key_press,
      refresh_begin => \&refresh,
      refresh_end   => \&refresh,
   );

   $self->idle;
}

sub leave {
   my ($self) = @_;

   delete $self->{overlay};

   $self->disable ("key_press", "refresh_begin", "refresh_end");

   $self->pty_ev_events ($self->{pty_ev_events});
   $self->want_refresh;
}

sub idle {
   my ($self) = @_;

   $self->msg ("scrollback search, escape=exit, enter=accept, /=start search, n=next, p=previous, G=bottom");

   delete $self->{in_search};
}

sub search {
   my ($self) = @_;

   my $row = -$self->view_start;

   delete $self->{found};

   no re 'eval'; # just to be sure
   my $re = qr/$self->{search}/;

   while ($row > -$self->nsaved) {
      my $line = $self->line ($row)
         or last;

      my $text = $line->t;
      if ($text =~ /$re/g) {
         do {
            push @{ $self->{found} }, [$line->coord_of ($-[0]), $line->coord_of ($+[0])];
         } while $text =~ /$re/g;

         $self->view_start (-$row + ($self->nrow >> 1));
         last;
      }

      $row = $line->beg - 1;
   }

   $self->msg ("enter/type/backspace: /$self->{search}_"
               . ($self->{found} ? "" : " (not found)"));
   $self->scr_bell unless $self->{found};
}

sub refresh {
   my ($self) = @_;

   return unless $self->{found};

   $self->scr_xor_span (@$_)
      for @{ $self->{found} };

   ()
}

sub key_press {
   my ($self, $event, $keysym, $string) =  @_;

   if (exists $self->{in_search}) {
      if ($keysym == 0xff0d || $keysym == 0xff8d) {
         $self->idle;
      } elsif ($keysym == 0xff1b) {
         $self->view_start ($self->{in_search});
         $self->idle;
      } elsif ($keysym == 0xff08) {
         substr $self->{search}, -1, 1, "";

         $self->search;
      } elsif ($string ne "") {
         $self->{search} .= $string;

         $self->search;
      }
   } else {
      if ($keysym == 0xff0d || $keysym == 0xff8d) {
         # OK
         $self->leave;
      } elsif ($keysym == 0xff1b) {
         $self->view_start ($self->{view_start});
         $self->leave;
      } elsif ($keysym == 0xff52) {
         $self->view_start ($self->view_start + 1);
      } elsif ($keysym == 0xff54) {
         $self->view_start ($self->view_start - 1);
      } elsif ($string eq "/") {
         $self->{in_search} = $self->view_start;
         $self->search;
      } elsif ($string eq "G") {
         $self->view_start (0);
      } elsif ($string eq "n") {
         $self->search;
      } elsif ($string eq "p") {
         # TODO
      } elsif ($string ne "") {
         $self->scr_bell;
      }
   }

   1
}


