#! perl

# this extension implements scrollback buffer search

sub on_init {
   my ($self) = @_;

   my $hotkey = $self->{argv}[0]
                || $self->x_resource ("searchable-scrollback")
                || "M-s";

   $self->parse_keysym ($hotkey, "perl:searchable-scrollback:start")
      or warn "unable to register '$hotkey' as scrollback search start hotkey\n";

   ()
}

sub on_keyboard_command {
   my ($self, $cmd) = @_;

   $cmd eq "searchable-scrollback:start"
      and $self->enter;

   ()
}

sub msg {
   my ($self, $msg) = @_;

   $self->{overlay} = $self->overlay (0, -1, $self->ncol, 1, urxvt::OVERLAY_RSTYLE, 0);
   $self->{overlay}->set (0, 0, $self->special_encode ($msg));
}

sub enter {
   my ($self) = @_;

   return if $self->{overlay};

   $self->{history} = [];
   $self->{view_start} = $self->view_start;
   $self->{pty_ev_events} = $self->pty_ev_events (urxvt::EVENT_NONE);

   $self->enable (
      key_press     => \&key_press,
      tt_write      => \&tt_write,
      refresh_begin => \&refresh,
      refresh_end   => \&refresh,
   );

   $self->{manpage_overlay} = $self->overlay (0, -2, $self->ncol, 1, urxvt::OVERLAY_RSTYLE, 0);
   $self->{manpage_overlay}->set (0, 0, "scrollback search, see the ${urxvt::RXVTNAME}perl manpage for details");

   $self->idle;
}

sub leave {
   my ($self) = @_;

   $self->disable ("key_press", "tt_write", "refresh_begin", "refresh_end");
   $self->pty_ev_events ($self->{pty_ev_events});

   delete $self->{manpage_overlay};
   delete $self->{overlay};
   delete $self->{history};
}

sub idle {
   my ($self) = @_;

   $self->msg ("escape=exit, enter=accept, /=start search, n=next, p=previous, G=bottom");

   delete $self->{in_search};
}

sub search {
   my ($self, $offset) = @_;

   my $row = -$self->view_start + ($self->nrow >> 1) + $offset;

   delete $self->{found};

   my $search = $self->special_encode ($self->{search});

   no re 'eval'; # just to be sure
   my $re = qr/$search/;

   while ($row > -$self->nsaved) {
      my $line = $self->line ($row)
         or last;

      my $text = $line->t;
      if ($text =~ /$re/g) {
         do {
            push @{ $self->{found} }, [$line->coord_of ($-[0]), $line->coord_of ($+[0])];
         } while $text =~ /$re/g;

         $self->view_start (-$row + ($self->nrow >> 1));
         last;
      }

      $row = $line->beg - 1;
   }

   $self->msg ("enter/type/backspace: /$self->{search}_"
               . ($self->{found} ? "" : " (not found)"));
   $self->scr_bell unless $self->{found};
}

sub refresh {
   my ($self) = @_;

   return unless $self->{found};

   $self->scr_xor_span (@$_, urxvt::SET_FGCOLOR (urxvt::RS_RVid, 15))
      for @{ $self->{found} };

   ()
}

sub key_press {
   my ($self, $event, $keysym, $string) =  @_;

   if (exists $self->{in_search}) {
      if ($keysym == 0xff0d || $keysym == 0xff8d) {
         $self->idle;
      } elsif ($keysym == 0xff1b) {
         $self->view_start ($self->{in_search});
         $self->idle;
      } elsif ($keysym == 0xff08) {
         substr $self->{search}, -1, 1, "";
         $self->search;
      } elsif ($string ne "") {
         return;
      }

   } else {
      if ($keysym == 0xff0d || $keysym == 0xff8d) {
         # TODO: set selection
         $self->leave;
      } elsif ($keysym == 0xff1b) {
         $self->view_start ($self->{view_start});
         $self->leave;
      } elsif ($keysym == 0xff52) {
         $self->view_start ($self->view_start + 1);
      } elsif ($keysym == 0xff54) {
         $self->view_start ($self->view_start - 1);
      } elsif ($string eq "/") {
         delete $self->{manpage_overlay};
         $self->{in_search} = $self->view_start;
         $self->search;
      } elsif ($string eq "G") {
         $self->{history} = [];
         $self->view_start (0);
      } elsif ($string eq "n") {
         if ($self->{found} && @{ $self->{found} }) {
            push @{ $self->{history} }, [$self->view_start, $self->{found}];
            $self->search (-1);
            $self->idle;
         }
      } elsif ($string eq "p" or $string eq "N") {
         if (my $prev = pop @{ $self->{history} }) {
            $self->view_start ($prev->[0]);
            $self->{found} = $prev->[1];
            $self->want_refresh;
         }
      } elsif ($string ne "") {
         $self->scr_bell;
      }
   }

   1
}

sub tt_write {
   my ($self, $data) = @_;

   $self->{search} .= $self->locale_decode ($data);
   $self->search;

   1
}


