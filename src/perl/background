#! perl

our $EXPR = 'move load "/root/pix/das_fette_schwein.jpg", repeat_wrap, X, Y';
$EXPR = 'rotate load "/root/pix/das_fette_schwein.jpg", W, H, 50, 50, counter 1/60, repeat_mirror';
#$EXPR = 'blur root, 10, 10'
#$EXPR = 'blur move (root, -x, -y), 5, 5'
#resize load "/root/pix/das_fette_schwein.jpg", w, h

use Safe;

our ($bgdsl_self, $old, $new);
our ($l, $t, $w, $h);

{
   package urxvt::bgdsl; # background language

   *repeat_black  = \&urxvt::RepeatNone; #TODO wtf
   *repeat_wrap   = \&urxvt::RepeatNormal;
   *repeat_pad    = \&urxvt::RepeatPad;
   *repeat_mirror = \&urxvt::RepeatReflect;

   sub load($) {
      my ($path) = @_;

      $new->{load}{$path} = $old->{load}{$path} || $bgdsl_self->new_img_from_file ($path);
   }

   sub root() {
      die "root op not supported, exg, we need you";
   }

#   sub clone($) {
#      $_[0]->clone
#   }

   sub subrect($$$$$;$) {
      $_[0]->sub_rect ($_[1], $_[2], $_[3], $_[4], $_[5])
   }

   sub resize($$$) {
      $_[0]->scale ($_[1], $_[2])
   }

   sub move($$$;$) {
      # TODO: must be simpler
      $_[0]->transform ($_[0]->w, $_[0]->h,
         1, 0, $_[1],
         0, 1, $_[2],
         0, 0,     1,
         $_[3],
      )
   }

   sub rotate($$$$$$;$) {
      $_[0]->rotate (
         $_[1],
         $_[2],
         $_[3] * $_[0]->w * .01,
         $_[4] * $_[0]->h * .01,
         $_[5] * (3.14159265 / 180),
         $_[6],
      )
   }

   sub blur($$$) {
      my ($img, $rh, $rv) = @_;

      $img = $img->clone;
      $img->blur ($rh, $rv);
      $img
   }

   sub contrast($$;$$;$) {
      my ($img, $r, $g, $b, $a) = @_;

      ($g, $b) = ($r, $r) if @_ < 4;
      $a       = 1        if @_ < 5;

      $img = $img->clone;
      $img->contrast ($r, $g, $b, $a);
      $img
   }

   sub brightness($$;$$;$) {
      my ($img, $r, $g, $b, $a) = @_;

      ($g, $b) = ($r, $r) if @_ < 4;
      $a       = 1        if @_ < 5;

      $img = $img->clone;
      $img->brightness ($r, $g, $b, $a);
      $img
   }

   sub X() { $new->{position_sensitive} = 1; $l }
   sub Y() { $new->{position_sensitive} = 1; $t }
   sub W() { $new->{size_sensitive}     = 1; $w }
   sub H() { $new->{size_sensitive}     = 1; $h }

   sub now() { urxvt::NOW }

   sub again($) {
      $new->{again} = $_[0];
   }

   sub counter($) {
      $new->{again} = $_[0];
      $bgdsl_self->{counter}++ + 0
   }
}

sub parse_expr {
   my $expr = eval "sub {\npackage urxvt::bgdsl;\n#line 0 'background expression'\n$_[0]\n}";
   die if $@;
   $expr
}

# compiles a parsed expression
sub set_expr {
   my ($self, $expr) = @_;

   $self->{expr} = $expr;
   $self->recalculate;
}

# evaluate the current bg expression
sub recalculate {
   my ($self) = @_;

   local $bgdsl_self = $self;

   local $old = $self->{state};
   local $new = my $state = $self->{state} = {};

   ($l, $t, $w, $h) =
      $self->get_geometry;

   my $img = eval { $self->{expr}->() };
   warn $@ if $@;#d#

   %$old = ();

   my $repeat;

   if (my $again = $state->{again}) {
      $repeat = 1;
      $state->{again} = urxvt::timer->new->after ($again)->cb (sub { $self->recalculate });
   }

   if (delete $state->{position_sensitive}) {
      $repeat = 1;
      $self->enable (position_change => sub { $_[0]->recalculate });
   } else {
      $self->disable ("position_change");
   }

   if (delete $state->{size_sensitive}) {
      $repeat = 1;
      $self->enable (size_change => sub { $_[0]->recalculate });
   } else {
      $self->disable ("size_change");
   }

   unless ($repeat) {
      delete $self->{state};
      delete $self->{expr};
   }

   $img = $img->sub_rect (0, 0, $w, $h)
      if $img->w != $w || $img->h != $h;

   $self->set_background ($img);
   $self->scr_recolour (0);
   $self->want_refresh;
}

sub on_start {
   my ($self) = @_;

   $self->set_expr (parse_expr $EXPR);

   ()
}

